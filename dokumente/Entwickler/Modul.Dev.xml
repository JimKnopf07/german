<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book id="Administration" lang="de-DE" revision="$Revision$"
      status="draft">
  <!-- $Id$ -->

  <title>Entwicklerdokumentation</title>

  <bookinfo>
    <copyright>
      <year>2002</year>

      <holder>Andreas Krapohl, andreas@krapohl.net</holder>
    </copyright>

    <releaseinfo>$Revision$</releaseinfo>

    <date>$Date$</date>
  </bookinfo>

  <preface>
    <title>Einleitung</title>

    <para>Postnuke ist ein offenes System, bei dem eigene Erweiterungen und
    verschiedene Layouts auf einfache Art und Weise eingebunden werden können.
    Postnuke bietet eine Reihe von API-Funktionen, die den Umgang mit dem
    System deutlich vereinfachen. So können selbst Postnuke-Neulinge relativ
    schnell erste Erfolge in der Modul-Programmierung erzielen.</para>

    <para><emphasis role="bold">Theme Entwicklung</emphasis></para>

    <para>Der erste Schritt nach der Basis-Installation ist meistens die
    Auswahl des Layouts. Soll die eigene Homepage jedoch nicht so aussehen wie
    Hunderttausend andere, empfiehlt es sich, selbst ein Theme zu schreiben.
    Schwer ist das nicht. Vor allem ist es oft am einfachsten, wenn man ein
    bestehendes Theme an die eigenen Vorstellungen anpaßt.</para>

    <para><emphasis role="bold">Modul Entwicklung</emphasis></para>

    <para>Für eine Vielzahl Anwendungen gibt es bereits sehr umfangreiche
    Lösungen. Doch gerade für kleinere, spezielle Probleme sollte sich der
    Postnuke-Admin auch selbst helfen können. Dafür gibt es im
    /modules-Verzeichnis ein Modul Namens 'Template', welches keinerlei
    Funktionalität besitzt, dafür aber den Aufbau von Postnuke-Modulen
    veranschaulicht. Dieses Modul wird gerne als Anfang von Modulentwicklungen
    benutzt.</para>

    <para><emphasis role="bold">Core Entwicklung</emphasis></para>

    <para>Selbstverständlich ist auch Hilfe bei der Entwicklung des
    Postnuke-Cores immer erwünscht. Diese Arbeit wird in einem öffentlich
    zugänglichen <ulink
    url="FAQ+index-myfaq-yes-id_cat-6-categories-CVS-parent_id-0.html">CVS</ulink>
    durchgeführt. Hier läßt sich stets der aktuellste Stand abrufen. Da diese
    aber nicht offiziell releast ist, sollte davon Abstand genommen werden,
    diese Version außer zu experimentellen Zwecken zu betreiben.</para>

    <para>Um hier eigene Anpassungen einfließen zu lassen, benötigt es
    sogennanten Commit-Rechten. Um diese zu erlangen und damit ins Core-Team
    aufgenommen zu werden, können zuvor eigene Code-Schnipsel im <ulink
    url="phpBB_14-viewforum-forum-16.html">deutschen</ulink> oder <ulink
    url="#">internationalen Forum</ulink> gepostet werden.</para>
  </preface>

  <chapter>
    <title>Modulentwicklung</title>

    <para><emphasis role="bold">Autoren und Versionen</emphasis></para>

    <para>Diese Einführung basiert auf der englischen Version 0.1 (3/9/2002)
    von Vivian Syneta und Daniel K. Schneider, die sie aus dem Französischen
    übersetzt haben.</para>

    <para>Die admin.php seit Postnuke Rogue</para>

    <para>Original von Pascal Riva und Gregor J. Rothfuss</para>

    <para>übersetzt von Steffen Voß</para>

    <para><emphasis role="bold">Vorwissen</emphasis></para>

    <para>Zum Vorwissen zur Modulprogrammierung zählen natürlich PHP- und
    SQL-Kenntnisse. Dieser Guide soll die grundlegenden Techniken bei der
    Postnuke-Modulentwicklung erläutern.</para>

    <para><emphasis role="bold">Ziele dieses Textes</emphasis></para>

    <itemizedlist>
      <listitem>
        <para>Die Architektur von Postnuke</para>
      </listitem>

      <listitem>
        <para>Was ist ein Modul? Wie ist es aufgebaut?</para>
      </listitem>

      <listitem>
        <para>Welche Schritte sind auf dem Weg zum fertigen Modul
        nötig?</para>
      </listitem>

      <listitem>
        <para>Weitere Tipps</para>
      </listitem>
    </itemizedlist>

    <para><emphasis role="bold">Anmerkung</emphasis> Die Vorlage dieses Textes
    war eine grobe englische Übersetzung aus dem Französischen - Die Fehler
    können nur mehr geworden sein ;)</para>

    <section>
      <title>Bevor Du anfängst</title>

      <para>Bevor Du anfängst brauchst Du eine funktionierende
      Postnuke-Testsite. Außerdem solltest Du Dir noch ein paar offizielle
      Dokumente suchen, ausdrucken und möglichst genau durchlesen.</para>

      <para>Außer hier auf Post-nuke.net solltest Du mal hier schauen:</para>

      <para><ulink
      url="http://www.postnuke.com/index.php">http://www.postnuke.com/index.php
      </ulink><ulink url="http://mods.postnuke.com">http://mods.postnuke.com
      </ulink><ulink
      url="http://support.postnuke.com">http://support.postnuke.com</ulink></para>

      <para><ulink
      url="http://noc.postnuke.com/docman/view.php/5/11/pnMDG.html">Postnuke
      Modul Entwickler Guide </ulink><ulink
      url="http://noc.postnuke.com/docman/view.php/5/10/pnAPI.htm">Postnuke
      API Befehlsreferenz </ulink><ulink
      url="http://noc.postnuke.com/docman/view.php/5/1/PostNuke%20Coding%20Standards.htm">Postnuke
      Kodierriechtlinien </ulink><ulink url="#">Postnuke ADODB
      Dokumentation</ulink></para>

      <para>Schau Dir andere Module an und laß Dich inspirieren, achte aber
      darauf, daß die auch vernünftig programmiert sind.</para>

      <para>Entscheide, welche Funktion Dein Modul haben soll und vergewissere
      Dich, daß es so ein Modul nicht schon gibt (Dann könntest Du Dir den
      Ärger evtl. sparen)</para>

      <para>Überlege Dir einen Namen (kurz soll er sein und möglichst komplett
      klein geschrieben) - Diesen kannst Du dann bei postnuke.com <ulink
      url="http://noc.postnuke.com/docman/view.php/5/13/PostNuke%20Module%20Registry.html">registrieren</ulink>,
      um Konflikte mit den Namen anderer Module zu verhindern.</para>

      <para>Soll Dein Modul ein 'Item' oder ein 'Utility' werden? Ein Item ist
      ein unanhängiges Modul, das nur den eigenen Content benutzt (zB. News,
      FAQ, Downloads). Ein Utility ist ein abhängiges Modul, das modulfremden
      Content manipuliert (zB. Kommentare, Ratings usw.) - Utilities nutzen
      meistens 'Hooks' für die Interaktion mit den anderen Modulen.</para>

      <para>Entwirf Dein Modul: Admin- und User-Funktionen müssen getrennt
      werden. Außerdem solltest Du GUI- von API-Funktionen trennen. Also
      Funktionen mit Ausgaben von denen, die im Hintergrund wirken.</para>

      <para>Entscheide, ob Du Blöcke benutzen willst.</para>

      <para>Jetzt mußt Du Dir Dein Datenbank-Design überlegen. Wenn Du Dir an
      diesem Punkt genügend Zeit läßt, kannst Du Dir eine Menge Streß später
      sparen.</para>

      <para>Nun kannst Du anfangen zu Programmieren (wenn Du alles, inkl.
      dieses Textes gelesen hast) ;)</para>

      <para>Wenn Du Hilfe brauchst, frag auf den einschlägigen Seiten in den
      Foren (post-nuke.net, postnuke.com, postnuke.de)</para>

      <para>Am Ende darfst Du natürlich nicht vergessen Deinen Quelltext zu
      dokumentieren, zu testen und als zip oder tar zu packen.</para>
    </section>

    <section>
      <title>Entwicklung</title>

      <para>Die grundlegende Struktur eines Moduls kannst Du Dir an dem Modul
      'Template' in deinem Postnuke-Verzeichnis anschauen. Dieses Modul hat
      keinerlei Funktion, außer daß es Einsteigern zeigen soll, wie ein Modul
      indealerweise aussieht. Viele Programmierer fangen auf Basis dieses
      Moduls mit Ihrer Entwicklung an.</para>
    </section>

    <section>
      <title>Tipps</title>

      <para>Überlege Dir Namen für die Funktionen, Variablen, Datenbankfelder
      usw. die mit dem namen des Moduls beginnen (zB.
      helloworld_variable1)</para>

      <para>Organisiere Deinen Quelltext in Funktionen (keine
      'main'-Funktion!). Um eine Funktion aufzurufen, benötigt man eine URL
      wie:</para>

      <para>index.php?module=joinproject&amp;type=admin&amp;func=main</para>

      <para>Parameter:
      module(=module_name),type(='user'_or_'admin'),func(=function_name)</para>
    </section>

    <section>
      <title>Struktur eines PostNuke-Moduls</title>

      <para>Alle Module liegen im 'modules'-Verzeichnis. Die Verzeichnisse
      hier tragen den selben Namen, wie die einzelnen Module. In einem dieser
      Verzeichnisse ähnelt die Dateistriktur in etwa diesem:</para>

      <para>modules/</para>

      <blockquote>
        <para>vquiz/</para>

        <blockquote>
          <para>pninit.php</para>

          <para>pntables.php</para>

          <para>pnadmin.php</para>

          <para>pnadminapi.php</para>

          <para>pnuser.php</para>

          <para>pnuserapi.php</para>

          <para>pnblocks/</para>

          <blockquote>
            <para>snapshot.php</para>
          </blockquote>

          <para>pnimages/</para>

          <blockquote>
            <para>admin.png</para>
          </blockquote>

          <para>pnlang/</para>

          <blockquote>
            <para>eng/</para>

            <blockquote>
              <para>admin.php</para>

              <para>user.php</para>

              <para>init.php</para>

              <para>manual.html</para>

              <para>snapshot.php</para>

              <para>pnversion.php</para>
            </blockquote>

            <para>deu/</para>

            <blockquote>
              <para>admin.php</para>

              <para>user.php</para>

              <para>init.php</para>

              <para>manual.html</para>

              <para>snapshot.php</para>

              <para>pnversion.php</para>
            </blockquote>
          </blockquote>
        </blockquote>
      </blockquote>

      <para>Die Administration ist seit Einführung der Rogue-Version (.7x) von
      Postnuke aus folgenden Files aufgebaut:</para>

      <para><itemizedlist>
          <listitem>
            <para>/admin.php - Diese Datei dient als eine Art Weiterleitung,
            um die Anfragen an das richtige Modul zu leiten</para>
          </listitem>

          <listitem>
            <para>/modules/admin/data.php - Enthält die Daten, um das
            Adminmenü zu erstellen (Es wird durch die "generate" Funktion in
            der version.php jedes Moduls erzeugt)</para>
          </listitem>

          <listitem>
            <para>/modules/$module/admin.php - Enthält alle Funktionen der
            Modulspezifischen Administration</para>
          </listitem>

          <listitem>
            <para>/modules/$module/admin/ - Enthält die "alten"
            Admin-Dateien</para>
          </listitem>

          <listitem>
            <para>/modules/$module/tools.php - Enthält Funktionen, die sowohl
            Admins als auch Usern zur Verfügung stehen sollen
            (optional)</para>
          </listitem>

          <listitem>
            <para>/modules/$module/images/admin.gif (oder jpg oder png) -
            Dieses Bild wird für das grafische Adminmenü benutzt - existiert
            es nicht, wird das Standart-Bild geladen</para>
          </listitem>
        </itemizedlist></para>

      <para>BTW: $modules ist Dein Modulname</para>
    </section>

    <section>
      <title>Wie baue ich ein Administrationsmenü auf?</title>

      <para></para>

      <para>In der admin.php wird das Haupt-Adminsitartionsmenü
      aufgebaut.</para>

      <para>Auf jede /modules/$module/admin.php wird ein Link ins Admin-Menü
      eingefügt. Diese Links bestehen aus:</para>

      <para><itemizedlist>
          <listitem>
            <para>URL - admin.php?module=$module&amp;op=main</para>
          </listitem>

          <listitem>
            <para>Bild - /modules/$module/images/admin.gif (oder .jpg oder
            .png)</para>
          </listitem>

          <listitem>
            <para>Text - _MODULE_NAME als Konstante (mit "_" und in
            Großbuchstaben) Definiert wird diese Konstante in
            /language/xxx/global.php</para>
          </listitem>
        </itemizedlist> Die Liste der Modullinks wird nicht jedesmal in
      Laufzeit neu eingelesen. Statt dessen wird sie in
      /modules/NS-Module/data.php gecachet. Um den Modul-Cache zu
      aktualisieren, wechselt man in die Moduladministration und klickt auf
      "Modulliste neu erzeugen".</para>

      <para>$module kann mit "NS-" geschrieben sein oder nicht - das ist nur
      der Verzeichnisname</para>

      <para>$module_name ist der Modulname ohne "NS-"</para>

      <para>Die Funktion ${module_name}_admin_main($var) (zB:
      kalender_admin_main() ) muß in der /modules/$module/admin.php definiert
      sein - diese Funktion wird standartmäßig aufgerufen.</para>
    </section>

    <section>
      <title>Modul Installation und Initialisation</title>

      <para>Postnuke verfügt über ein Interface zum initialisieren,
      aktivieren/deaktiveren oder entfernen von Modulen (und deren
      Datenbank-Tabellen) - Die Dateien, die die dafür wichtigen Informationen
      enthalten sind: <filename>pntables.php</filename> und
      <filename>pninit.php</filename></para>

      <bridgehead>Datenbanktabellen in der pntables.php</bridgehead>

      <para>In dieser Datei gibt es eine Funktion, die die Postnuke-Variable
      "<varname>pntable</varname>" mit den Namen aller Tabellen und Felder
      füllt, die das Modul nutzt.</para>

      <para>Beispiel: Tabelle "pn_joinproject_members" mit vier Feldern</para>

      <programlisting>function joinproject_pntables() { 
  // Initialise table array 
  $pntable = array(); 

  // Get the name for the template item table. 
  $members = pnConfigGetVar('prefix') . '_joinproject_members'; 

  // Set the table name 
  $pntable['joinproject_members'] = $members; 

  // Set the column names. 
  $pntable['joinproject_members_column'] = array('memberid'   =&gt; $members . '.memberid', 
                                                 'projid'     =&gt; $members . '.projid', 
                                                 'membername' =&gt; $members . '.membername', 
                                                 'accepted'   =&gt; $members . '.accepted'); 
  // Return the table information 
  return $pntable; 
}</programlisting>

      <bridgehead>Erzeugt oder gelöscht werden die Tabellen in der
      pninit.php</bridgehead>

      <para>Dabei gibt es 2 Funktionen: <function>init()</function> und
      <function>delete()</function></para>

      <para>In der init()-Funktion werden die benötigten Tabellen in der
      Datenbank angelegt, indem schlichte SQL-Queries aufgerufen
      werden.</para>

      <para>function joinproject_init() {</para>

      <blockquote>
        <para>list($dbconn) = pnDBGetConn();</para>

        <para>$pntable = pnDBGetTables();</para>

        <para>$memberstable = $pntable['joinproject_members'];</para>

        <para>$memberscolumn =
        &amp;$pntable['joinproject_members_column'];</para>

        <para>$sql1 = "CREATE TABLE $memberstable ( $memberscolumn[memberid]
        tinyint unsigned NOT NULL auto_increment,</para>

        <para>$memberscolumn[projid] tinyint unsigned NOT NULL default
        '',</para>

        <para>$memberscolumn[membername] varchar(255) NOT NULL default
        '',</para>

        <para>$memberscolumn[accepted] tinyint(1) NOT NULL default '0',
        PRIMARY KEY(memberid))";</para>

        <para>$dbconn-&gt;Execute($sql1);</para>

        <para>// Check for an error with the database code, and if so set
        an</para>

        <para>// appropriate error message and return</para>

        <para>if ($dbconn-&gt;ErrorNo() != 0) {</para>

        <blockquote>
          <para>pnSessionSetVar('errormsg', _CREATETABLEFAILED);</para>
        </blockquote>

        <para>return false;</para>

        <para>}</para>
      </blockquote>

      <para>}</para>

      <para>In der delete()-Funktion werden die Datenbank-Tabellen mit dem
      SQL-Befehl "DROP TABLE" widerum gelöscht.</para>

      <para>function joinproject_delete(){</para>

      <blockquote>
        <para>list($dbconn) = pnDBGetConn();</para>

        <para>$pntable = pnDBGetTables();</para>

        <para>$sql1 = "DROP TABLE $pntable[joinproject_members]";</para>

        <para>$dbconn-&gt;Execute($sql1);</para>

        <para>// Check for an error with the database code, and if so set
        an</para>

        <para>// appropriate error message and return</para>

        <para>if ($dbconn-&gt;ErrorNo() != 0) {</para>

        <blockquote>
          <para>pnSessionSetVar('errormsg', _DROPTABLEFAILED);</para>
        </blockquote>

        <para>return false;</para>

        <para>}</para>

        <para>// Deletion successful return true;</para>
      </blockquote>

      <para>}</para>

      <bridgehead>Testen</bridgehead>

      <para>Werden die Tabellen in der Datenbank tatsächlich angelegt und
      gelöscht?</para>

      <para>Administration &gt; Module &gt; Liste neu erzeugen &gt;
      "MeinModul"</para>

      <para>Initialisieren</para>

      <para>Aktivieren</para>

      <para>Entfernen</para>
    </section>

    <section>
      <title>Admin- und User-Interface</title>

      <para>Admin Interface:</para>

      <para>Zugang zur Modul-Administration über die
      Site-Administration</para>

      <para>User Interface:</para>

      <para>Zugriff entweder über die Site-Navigation (zB. Main Menu) - hier
      baut man einen Link zum Modul ein (zB. Title=MeinModul,
      URL=[MyModul])</para>

      <para>oder über das Erstellen eines neuen Blocks, der den Namen des
      Moduls trägt</para>

      <para>oder oder oder...</para>

      <para><emphasis role="bold">Funktionen in der
      /modules/$module/admin.php</emphasis></para>

      <para>Die Funktionen werden vond er /admin.php durch die Übergabe des
      $op-Parameters an die admin.php aufgerufen. Deswegen muß für jede $op
      eine Funktion definiert sein. Der Name der Funktion muß dann nach dem
      Muster $module_name.'_admin_'.$op zusammengesetzt werden. Alle weiteren
      Parameter werden als Array über HTTP_POST_VARS und HTTP_GET_VARS als
      $var weitergereicht. Deswegen ist $module_admin_main($var) der Name der
      Main-Funktion.</para>

      <para>Wie schon erwähnt werden alle Anfragen an die Administration eines
      Moduls über die /admin.php geroutet. Bei einem Aufruf sucht sie die
      gefragte Funktion ($module_name.'_admin_$op) in der dazugehörigen
      /modules/$module/admin.php. Zum Beispiel wird der Aufruf:</para>

      <para>/admin.php?module=$module_name&amp;op=$your_method</para>

      <para>an die /modules/$module_name/admin.php weitergreicht, in dem diese
      Datei in die /admin.php includet wird, um dann die Funktion
      $module_name.'_admin_.$your_method aufzurufen. Sollte die gesucht
      Funktion nicht gefunden werden, wird einfach auf die Main()
      zurückgegriffen.</para>

      <para>Die Main()-Funktion kann auch weiterleitungen auf anderen $op
      enthalten. (siehe unten)</para>

      <bridgehead>GUI- von API-Funktionen trennen</bridgehead>

      <para></para>

      <para>GUI: pnadmin.php, pnuser.php</para>

      <para>API: pnadminapi.php, pnuserapi.php</para>

      <bridgehead></bridgehead>

      <para><emphasis role="bold">In Funktionen und Klassen
      organisieren</emphasis></para>

      <para>Funktionennamen in der pnadmin.php und der pnadminapi.php sind
      folgendermaße zu benennen:</para>

      <para>mymodule_admin_function() (zB. mymodule_admin_main() )</para>

      <para>In der pnuser.php und der pnuserapi.php sieht das so aus:</para>

      <para>mymodule_user_function() (zB. mymodule_user_main() )</para>

      <para><emphasis role="bold">Einige Bespiele für
      Standard-Funktionen</emphasis></para>

      <para>Es gibt keine festen Regeln für Funktionsnamen. Es hat sich bietet
      sich aber an, die gleichen Namen wie viele andere zu benutzen</para>

      <para>$module_name.'_admin_main'</para>

      <para>Die Admin-Hauptseite - diese Funktion ist <emphasis
      role="bold">muß</emphasis>. In den meisten Fällen laufen Anfragen an
      Dein Modul über diese Funktion.</para>

      <para>$module_name.'_admin_modify'</para>

      <para>Funktion zu editieren von Daten, um danach ein Update
      durchzuführen</para>

      <para>$module_name.'_admin_update'</para>

      <para>Funktion zum updaten einer Datenbanktabelle - im Anschluß kehrt
      man wieder zur main() zurück.</para>

      <para>$module_name.'_admin_create'</para>

      <para>Funktion zum editieren von Daten vor einem Insert.</para>

      <para>Anmerkung: Eine gemeinsame Funktion bietet nur ein Forumular für
      Updates und Inserts</para>

      <para>$module_name.'_admin_insert'</para>

      <para>Funktion zum Einfügen von Daten in die Datenbank - Danach kehrt
      man zur main() zurück</para>

      <para>$module_name.'_admin_suppress'</para>

      <para>Funktion zur Bestätigung von Löschvorgängen</para>

      <para>$module_name.'_admin_delete'</para>

      <para>Funktion zum Löschen von Daten aus der Datenbank - Danach kehrt
      man zur main() zurück</para>

      <para><emphasis role="bold">4.3. API-Funktionen
      benutzen</emphasis></para>

      <para>Zu den verfügbaren API-Funktionen siehe auch die <ulink url="#">
      API-Dokumentation</ulink></para>

      <para>zB. die Funktion pnModURL()</para>

      <blockquote>
        <para>pnModURL('joinproject', 'user', 'main')</para>
      </blockquote>

      <para>oder</para>

      <blockquote>
        <para>pnRedirect(pnModURL('joinproject', 'admin', 'main'));</para>
      </blockquote>

      <para>usw.</para>

      <para><emphasis role="bold">4.4 SQL &amp; die ADODB</emphasis></para>

      <para>Postnuke nutzt die ADODB-Bibliothek für die Datenbankzugriffe.
      Auch hier gilt - Dokumentation lesen!</para>

      <para>zB.</para>

      <para>list($dbconn) = pnDBGetConn();</para>

      <para>$pntable = pnDBGetTables();</para>

      <para>$projectstable = $pntable['joinproject_projects'];</para>

      <para>$result1=$dbconn-&gt;Execute("SELECT * FROM
      $projectstable");</para>

      <para><emphasis role="bold">4.5 Fehler abfangen</emphasis></para>

      <para>Postnuke verfügt über ein internes System zur Fehlerbehandlung und
      es liegt in jedermanns interesse, dieses zu nutzen. Siehe Doku.</para>

      <para><emphasis role="bold">4.6 Sicherheit und
      Zugriffsrechte</emphasis></para>

      <para>Postnuke verfügt über ein ausgefeiltes System der <ulink url="#">
      Rechtevergabe</ulink>. Aus diesem Grund gibt es die API-Funktion
      pnSecAuthAction(), die am Anfang jeder Funktion aufzurufen sind, um
      Sicherheitslücken zu vermeiden:</para>

      <para>if (!pnSecAuthAction(0, 'joinproject::', '::', ACCESS_ADMIN))
      {</para>

      <para>$output-&gt;Text(_TEMPLATENOAUTH);</para>

      <para>return $output-&gt;GetOutput(); }</para>

      <para>Diese drei Zeilen kann man so nehmen und ins eigene Modul
      einkopieren. Sie bewirken, dass Personen ohne ausreichende
      Zugriffsrechte den Text angezeigt bekommen, der in der mittleren Zeile
      aufgerufen wird. Natürlich müssen/können diese Zeilen angepaßt werden.
      Die Funktion pnSecAuthAction() ist folgendermaßen definiert:</para>

      <para>bool pnSecAuthAction(realm, component, instance, level,
      uid(opt));</para>

      <para><emphasis role="bold">realm</emphasis> ist zur Zeit immer 0</para>

      <para><emphasis role="bold">component</emphasis> ist die Komponente, für
      die das Recht gelten soll. Das ist normalerweise ganz allgemein das
      Modul, bzw eine bestimmte Teilfunktion des Modul. Wenn ein Modul zum
      Beispiel aus einem Editor und einer Übersicht besteht, dann kann man die
      Komponente Modulname::Editor bzw Modulname::Overview nennen.</para>

      <para><emphasis role="bold">instance</emphasis> ist der ganz spezielle
      Fall. Soll der User nur auf einen ganz bestimmten Beitrag mit dem Editor
      zugreifen dürfen, würde man hier die aktuelle Beitrags-id abfragen:
      $variable::</para>

      <para><emphasis role="bold">level</emphasis> ist die Zugriffsebene. Es
      gibt verschiedene Ebenen des Zugriffs (siehe Doku):</para>

      <para>ACCESS_NONE - Kein Zugriff</para>

      <para>ACCESS_OVERVIEW - Eine Übersicht des Inhalts darf gesehen
      werden</para>

      <para>ACCESS_READ - Leserechte</para>

      <para>ACCESS_COMMENT Kommentieren erlaubt</para>

      <para>ACCESS_MODERATE Moderieren erlaubt</para>

      <para>ACCESS_EDIT Editieren erlaubt</para>

      <para>ACCESS_ADD Hinzufügen erlaubt</para>

      <para>ACCESS_DELETE Löschen erlaubt</para>

      <para>ACCESS_ADMIN Vollzugriff</para>
    </section>

    <section>
      <title>Mehrsprachige Module</title>

      <para></para>

      <para>Wie macht man ein Modul "international" (d.h.
      mehrsprachig)?</para>

      <para>Statt Text benutzt man Konstanten (zB. _HALLO) im Quelltext - im
      Modulverzeichnis unter pnlang legt man nun für jede gewünschte Sprache
      ein Verzeichnis an (zB. "deu", "eng", "fra") und legt dort jeweils die
      Dateien "admin.php" und "user.php" an.</para>

      <para>Beispiel 1: Die Datei mymodule/pnlang/eng/admin.php</para>

      <blockquote>
        <para>&lt;?php</para>

        <para>define("_MODULETITLE","Join Project module");</para>

        <para>define("_ADMININTERFACE","Interface administrateur");</para>

        <para>define("_LISTOFPROJECTS","Liste des projets");</para>

        <para>?&gt;</para>
      </blockquote>

      <para>Beispiel 2: Die Datei mymodule/pnlang/eng/user.php</para>

      <blockquote>
        <para>&lt;?php</para>

        <para>define("_MODULETITLE","Join Project");</para>

        <para>define("_JOINAPROJECT","Joindre un projet");</para>

        <para>define("_LISTOFPROJECTS","Liste des projets");</para>

        <para>?&gt;</para>
      </blockquote>

      <para>Beispiel 3: Verwendung der Konstanten aus der "pnadmin.php" und
      "user.php":</para>

      <blockquote>
        <para>$output-&gt;Title(_MODULETITLE);</para>
      </blockquote>

      <para>Ich möchte aber noch zu bedenken geben, daß allein durch die
      Mehrsprachigkeit des Frontends keine echte Mehrsprachigkeit erzeugen
      läßt - dazu müssen auch die Inhalte in verschiedenen Sprachen
      gespeichert werden. Problem ist aber, daß man den Usern, die zB. Ihre
      Beiträge schreiben, nicht zumuten kann, Ihren Beitrag in allen auf der
      Site verwendeten Sprachen abzuliefern.</para>
    </section>
  </chapter>

  <chapter>
    <title>Suchfunktion anbieten</title>

    <para>Mit dem 'Search'-Modul bietet PostNuke eine zentrale Stelle für die
    Suche in den Modulen. Dafür muss das jeweilige Modul einentsprechendes
    PHP-Skript in includes/search hinterlegen. In diesem Skript werden zwei
    Funktionen definiert, von denen die eine für die Definition der
    Suchfunktion zuständig ist, die andere für die Auswerung der Sucheingabe
    und die eigentliche Suche.</para>

    <para>Im Skript muß PostNuke zunächst mitgeteilt werden, wiediese
    Funktionen heißen. Dazu werden die entsprechenden Informationen an den
    Array $search_modules angehängt:</para>

    <para>$search_modules[] = array( 'title' =&gt; foobar',</para>

    <para>'func_search' =&gt; 'search_foobar',</para>

    <para>'func_opt' =&gt; 'search_foobar_opt'); Mit der Funktion
    search_foobar_opt() werden nun die erweiterten Suchfunktionen definiert.
    Zumindest muß in dieser Funktion einecheckbox ausgegeben werden, die
    angibt, ob der Suchbereich aktiviert werden muß. Der Name dieser checkbox
    kann prinzipiell freigewählt werden; als Konvention hat sich aber
    active_xxx durchgesetzt; bei uns also active_foobar.</para>

    <para>Um die Zeile im PostNuke-Standard zu gestalten, sollte sie als
    eineTabelle mit einer Zeile und einer Spalte ausgegeben werden, wobei
    dieFarben durch die im Theme hinterlegten Werte $bgcolor1 und
    $textcolor1definiert sind.</para>

    <para>Zu beachten ist, dass zunächst geprüft werden soll, ob der Benutzer
    berechtigt ist, das Modul überhaupt zu benutzen. Dazudient die
    pnSecAuthAction-Abfrage.</para>

    <para>function search_foobar_opt() {</para>

    <para>if (!pnSecAuthAction(0, 'foobar::', '::', ACCESS_READ)) {</para>

    <para>return;</para>

    <para>}</para>

    <para>global $bgcolor2, $textcolor1;</para>

    <para>$output = new pnHTML();</para>

    <para>$output-&gt;SetInputMode(_PNH_VERBATIMINPUT);</para>

    <para>$output-&gt;Text('&lt;table border='0' width='100%'&gt;');</para>

    <para>$output-&gt;Text('&lt;tr bgcolor='$bgcolor2'&gt;&lt;td&gt;');</para>

    <para>$output-&gt;Text('&lt;fontclass='pn-normal'style='text-color:$textcolor1'&gt;');</para>

    <para>$output-&gt;Text('&lt;inputtype='checkbox'name='active_foobar'
    id='active_foobar' value='1' checked&gt; ');</para>

    <para>$output-&gt;Text('&lt;labelfor='active_foobar'&gt;'._SEARCH_FOOBAR.'&lt;/label&gt;');</para>

    <para>$output-&gt;Text('&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;');</para>

    <para>// Hier können nun noch weitere Felder ausgegeben werden, diefür
    dies Modul spezifisch sind.</para>

    <para>// Beispiele könnten sein: Suche nur nach Beiträgen vonbestimmten
    Autoren, suche nur Termine in bestimmten Zeitraum usw.</para>

    <para>return $output-&gt;GetOutput();</para>

    <para>} Die eigentliche Suche übernimmt nun search_foobar(). Die für die
    Suche wichtigen Werte werden dabei per pnVarCleanFromInput abgeholt. Der
    wichtigste Wert ist natürlich der Suchstring, der als 'q' der Suche
    übergeben wird, sowie die Art der Suche bei mehreren Begriffen 'UND' oder
    'ODER' als 'bool'. Ferner natürlich der Wert der Checkbox, ob überhaupt in
    diesem Modul gesucht werden soll('active_foobar') sowie die evtl. weiteren
    Informationen, die der Suche übergeben werden sollen.</para>

    <para>function search_foobar() {</para>

    <para>// Feststellen, ob überhaupt gesucht werden soll</para>

    <para>$active_foobar = pnVarCleanFromInput('active_foobar');</para>

    <para>if(empty($active_google)) {</para>

    <para>return;</para>

    <para>}</para>

    <para>// Abholen der Standardwerte für die Suche</para>

    <para>list($q, $bool) = pnVarCleanFromInput('q', 'bool');</para>

    <para>Mit diesen Werten wird nun die eigentliche Suche durchgeführt.Will
    man Werte aus einer Datenbank abfragen, so muß man sich zunächst einen
    entsprechenden SQL-Query zusammenbasteln. Die (PostNuke-eigene) Funktion
    search_split_query($q) macht dazu aus dem Suchstring, in dem ja
    verschiedene Begriffe durch Leerzeichen getrennt sein können, einen Array
    mit dieser Werten, die bereits vom 'Wildcard-Zeichen' von MySQL, '%',
    umschlossen sind. Ferner wird der Suchstring mit <ulink url="#">
    pnVarPrepForStore()</ulink> bearbeitet, so dass man das Ergebnis sorglos
    auf die Datenbank loslassen kann.</para>

    <para>Für den Query hat sich folgendes Codefragment als nützlich erwiesen.
    Noch bequemer geht es natürlich mit einerModul-API-Funktion, sofern dieser
    zur Verfügung steht.</para>

    <para>// Tabellenstruktur</para>

    <para>$pntable = pnDBGetTables();</para>

    <para>$foocol = &amp;$pntable['foobar_column'];</para>

    <para>// welche Felder?</para>

    <para>$query = 'SELECT $foocol[feld1] as feld1, $foocol[feld2] as
    feld2</para>

    <para>FROM $pntable[foobar]</para>

    <para>WHERE ';</para>

    <para>// WHERE-Teil basteln</para>

    <para>$w = search_split_query($q);</para>

    <para>$where_array = array();</para>

    <para>foreach($w as $word) {</para>

    <para>$where_array[] = '( $foocol[feld1] LIKE '$word'OR foocol[feld2] LIKE
    '$word' )';</para>

    <para>}</para>

    <para>if ($bool == 'AND') {</para>

    <para>$andor = ' AND ';</para>

    <para>} else {</para>

    <para>$andor = ' OR ';</para>

    <para>}</para>

    <para>$query .= implode($andor, $where_array);</para>

    <para>// Sortierung</para>

    <para>$query .= ' ORDER BY $foocol[feld1]'; Mit diesem Query-String wird
    nun die Datenbank abgefragt und die Ergebnisse angezeigt. Dabei sollte vor
    der Ausgabe eines jeden Wertes darauf geachtet werden, ob der Anwender
    berechtigt ist, diesen Eintragüberhaupt zu sehen.</para>

    <para>list($dbconn) = pnDBGetConn();</para>

    <para>$result = $dbconn-&gt;execute($query);</para>

    <para>$result_array = array();</para>

    <para>while(!$result-&gt;EOF) {</para>

    <para>$row = $result-&gt;GetRowAssoc(false);</para>

    <para>// Sicherheit prüfen!</para>

    <para>if (pnSecAuthAction(0, 'foobar::foo', '::$row[feld1]',ACCESS_READ))
    {</para>

    <para>// hier natürlich den richtigen Linkeintragen!</para>

    <para>$result_array[]='&lt;li&gt;&lt;aclass='pn-normal'href='....&amp;id=$row[feld1]'&gt;$row[feld2]&lt;/a&gt;&lt;/li&gt;';</para>

    <para>}</para>

    <para>$result-&gt;MoveNext();</para>

    <para>}</para>

    <para>$output = new pnHTML();</para>

    <para>$output-&gt;SetInputMode(_PNH_VERBATIMINPUT);</para>

    <para>if (empty($result_array)) {</para>

    <para>$output-&gt;SetInputMode(_PNH_VERBATIMINPUT);</para>

    <para>$output-&gt;Text('&lt;fontclass='pn-normal'&gt;'._SEARCH_NO_FOOBAR.'&lt;/font&gt;');</para>

    <para>$output-&gt;SetInputMode(_PNH_PARSEINPUT);</para>

    <para>} else {</para>

    <para>$output-&gt;Text('&lt;font class='pn-normal'&gt;' ._FOOBAR . ': ' .
    count($result_array) . ' ' . _SEARCHRESULTS .'&lt;/font&gt;');</para>

    <para>$output-&gt;Text('&lt;ul&gt;');</para>

    <para>$output-&gt;Text(implode(' ', $result_array));</para>

    <para>$output-&gt;Text('&lt;/ul&gt;');</para>

    <para>}</para>

    <para>$output-&gt;Linebreak();</para>

    <para>return $output-&gt;GetOutput();</para>

    <para>}</para>

    <section remap="h4">
      <title>Andere Suchquellen</title>

      <para>Natürlich lassen sich auf diese Art nicht nur die moduleigenen
      Datenbanken durchsuchen. Denkbar ist z.B. die Einbindung einer externen
      Suchmaschine und die Darstellung der gefundenen Seiten auf der eigenen
      Seite (wobei dies rechtlich problematisch sein kann!), oder die Abfrage
      lokaler Indizes, etwa von <ulink
      url="http://htdig.sourceforge.net/">ht://dig</ulink>, <ulink
      url="http://swish-e.org/">swish-e</ulink> o.ä. Alles, was man in diesem
      Falle benötigt, ist ein Befehl, der den Suchstring entgegennimmt und die
      Suchergebnisse auf der Standardausgabe wieder ausgibt.</para>

      <para>Zu beachten ist, dass man in diesem Falle den Suchstring auf jeden
      Fall mit pnVarPrepForOS behandeln muß!</para>

      <para>Hier eine sehr simple Implementierung für swish-e:</para>

      <para>function search_swish()</para>

      <para>{</para>

      <para>// Feststellen, ob überhaupt gesucht werden soll</para>

      <para>$active_swish = pnVarCleanFromInput('active_swish');</para>

      <para>if (empty($active_swish)) {</para>

      <para>return;</para>

      <para>}</para>

      <para>// Abholen der Standardwerte für die Suche</para>

      <para>list($q, $bool) = pnVarCleanFromInput('q', 'bool');</para>

      <para>// Aus der Suchanfrage die Parameter für den lokalen Index
      bauen</para>

      <para>$w = array();</para>

      <para>$stripped = pnVarPrepForOS($q);</para>

      <para>$qwords = explode(' ', $stripped);</para>

      <para>foreach($qwords as $word) {</para>

      <para>$w[] = $word . '*';</para>

      <para>}</para>

      <para>if ($bool == 'AND') {</para>

      <para>$andor = ' and ';</para>

      <para>} else {</para>

      <para>$andor = ' or ';</para>

      <para>}</para>

      <para>$query .= implode($andor, $w);</para>

      <para>// Abfrage von swish</para>

      <para>$SearchEngineBinary = '/usr/home/boi/bin/swish2';</para>

      <para>$SearchEngineIndex = '/usr/home/foo/bar.idx';</para>

      <para>$SearchEngineCommand = "$SearchEngineBinary -f $SearchEngineIndex
      -w $query ";</para>

      <para>exec($SearchEngineCommand, $results, $return);</para>

      <para>// Aus den Ergebnissen eine Ausgabe erzeugen</para>

      <para>$result_array = array();</para>

      <para>if ($return == 0) {</para>

      <para>foreach($results as $result) {</para>

      <para>if (substr($result, 0, 1) != "#" &amp;&amp; $result != '.')
      {</para>

      <para>$line = explode(" ", $result);</para>

      <para>$result_array[] = "&lt;li&gt;$line[1]&lt;/li&gt;";</para>

      <para>}</para>

      <para>}</para>

      <para>}</para>

      <para>$output = new pnHTML();</para>

      <para>$output-&gt;SetInputMode(_PNH_VERBATIMINPUT);</para>

      <para>if (empty($result_array)) {</para>

      <para>$output-&gt;SetInputMode(_PNH_VERBATIMINPUT);</para>

      <para>$output-&gt;Text('&lt;font class="pn-normal"&gt;' .
      _SEARCH_NO_FOOBAR . '&lt;/font&gt;');</para>

      <para>$output-&gt;SetInputMode(_PNH_PARSEINPUT);</para>

      <para>} else {</para>

      <para>$output-&gt;Text('&lt;font class="pn-normal"&gt;' . _FOOBAR . ': '
      . count($result_array) . ' ' . _SEARCHRESULTS . '&lt;/font&gt;');</para>

      <para>$output-&gt;Text('&lt;ul&gt;');</para>

      <para>$output-&gt;Text(implode("\n", $result_array));</para>

      <para>$output-&gt;Text('&lt;/ul&gt;');</para>

      <para>}</para>

      <para>$output-&gt;Linebreak();</para>

      <para>return $output-&gt;GetOutput();</para>

      <para>}</para>
    </section>
  </chapter>

  <chapter>
    <title>Eigene Symbole im Benutzermenü</title>

    <para>Mit einer einfachen Methode ist es möglich, Symbole im Benutzermenü
    ('My Account') hinzuzufügen oder bestehende zu löschen.</para>

    <para>Im Verzeichnis modules/NS-Your_Account/user/links befinden sich
    Dateien mit dem Namen links.xxx.php. Diese Dateien sind für die
    Funktionalitäten zuständig, die im Benutzernemü angezeigt wird.</para>

    <para>Dabei sind folgende Dateien für die in der Tabelle angegebenen
    Symbole zuständig. Löscht man die entsprechende Datei, so verschwindet
    auch das zugehörige Symbol.</para>

    <para>In der normalen Installation liegen in dem Verzeichnis schon 3
    Links: <itemizedlist>
        <listitem>
          <para>links.changehome.php - Startseite anpassen</para>
        </listitem>

        <listitem>
          <para>links.changeinfo.php - Profil ändern</para>
        </listitem>

        <listitem>
          <para>links.changetheme.php - Theme wählen</para>
        </listitem>
      </itemizedlist> Schon an diesen Dateinamen kann man erkennen, daß der
    eigene hinzugefügte Link ebenfalls nach dem Muster link.*.php formatiert
    sein sollte.</para>

    <para>Der Aufbau der Datei ist recht langweilig; interessant ist genau
    eine Zeile:</para>

    <para><literal>usermenu('index.php', 'foobar',
    'info.gif');</literal></para>

    <para>Die Parameter sind die URL, zu der gesprungen werden soll, der
    anzuzeigende Menütext und das zugehörige Bild.</para>

    <para>Legt man also eine neue Datei, die diese Zeile enthält, in das
    Verzeichnis, so erhält man eine neues Symbol; und beim Anklicken wird zum
    angegebenen Link gesprungen.</para>
  </chapter>

  <chapter>
    <title>Hooks</title>

    <para><emphasis role="bold">Saintego</emphasis> beschreibt bei <ulink
    url="http://www.ivory-tower.net/">ivory-tower.net</ulink> die
    Möglichkeiten des Einsatzes von Hooks.</para>

    <para>Die Idee ist einfach: Man kann dem einen Modul den Zugriff auf einen
    "Hook" in einem anderen Modul ermöglichen. Unter Admin/Module/editieren
    werden die derzeit registrieren Hooks angezeigt, die sich Modulspezifisch
    an- und abschalten lassen. So wird endlich die oft so vermisste
    Zusammenarbeit der Module möglich.</para>

    <para>Quellen: <ulink
    url="http://www.ivory-tower.net/">ivory-tower.net</ulink>, <ulink
    url="http://noc.postnuke.com/docman/view.php/5/10/pnAPI.htm">PostNuke API
    Command Reference</ulink></para>

    <para>Übertragen aus dem Englischen von <emphasis
    role="bold">ArschMitOhren</emphasis>, erweitert von <emphasis
    role="bold">jn</emphasis></para>

    <section remap="h4">
      <title>Hooks definieren</title>

      <para>Ein Modul kann einen <emphasis role="bold">Hook
      bereitstellen</emphasis>. Das bedeutet, dass dieses Modul in der Lage
      ist, auf Ereignisse in <emphasis>anderen</emphasis> Modulen zu
      reagieren. So könnte z.B. ein Modul immer dann eine Mail an den
      Administrator verschicken, wenn sich ein neuer Benutzer auf der Seite
      registriert. Eine andere Möglichkeit ist es, Text zu verändern. So
      arbeiten die "Autolinks": Jedes Mal, wenn ein bestimmter
      Schlüsselbegriff im Text vorkommt, wird dieser durch einen
      entsprechenden Link ersetzt.</para>

      <para>Hooks können für zwei verschiedene <emphasis
      role="bold">Objekte</emphasis> bereitgestellt werden: Für ein 'item'
      oder für eine 'category'. Dabei ist ein 'item'-Hook für die Behandlung
      eines Datensatzes (z.B. eines Artikels) zuständig, während ein
      'category"-Hook für die Behandlung einer Übersichtsseite zuständig
      ist.</para>

      <para>Hooks können für verschiedene <emphasis
      role="bold">Aktionen</emphasis> definiert werden: 'create', 'delete',
      'transform', oder 'display'. Je nachdem, ob das aufrufende Modul etwas
      anlegt, löscht, anzeigt oder zur Anzeige vorbereitet, werden die
      entsprechenden Hooks aufgerufen.</para>

      <para>Hooks können in verschiedenen <emphasis
      role="bold">Bereichen</emphasis> agieren, im GUI-Bereich oder im
      API-Bereich. GUI-Hooks geben direkt etwas aus, während API-Hooks "im
      Hintergrund" arbeiten, also z.B. einen Text verändern, Mails versenden
      usw.</para>

      <para>GUI-Hooks können ausschließlich mit der Aktion 'display' verwendet
      werden, API-Hooks ausschließlich mit den anderen Aktionen.</para>

      <para>Jedes Modul, das Hooks verwendet (also diese aufruft), bestimmt
      selbst, zu welcher Zeit welche Hooks aufgerufen werden. So ruft z.B. das
      News-Modul die 'item'-Hooks, die eine Transformation liefern, auf,
      nachdem der Artikel aus der Datenbank gelesen wurde; Content Express
      ruft die 'item'-Hooks, die über das Anlegen informiert werden müssen,
      nach dem Eintragen eines neuen Beitrags in die Datenbank, usw.</para>

      <para>Hooks werden also für gewisse Ereignisse bereitgestellt; und die
      Module rufen die Hooks ab, sobald diese Ereignisse eintreten. Damit das
      PostNuke-System weiß, dass ein bestimmter Hook existiert, muß dieser
      zunächst registriert werden. Das übernimmt die Funktion
      pnModRegisterHook, die die folgende Syntax hat:</para>

      <para><function>pnModRegisterHook(<varname>hookobject</varname>,
      <varname>hookaction</varname>, <varname>hookarea</varname>,
      <varname>hookmodule</varname>, <varname>hooktype</varname>,
      <varname>hookfunc</varname>);</function></para>

      <para>Die einzelnen Parameter haben die folgende Bedeutung:</para>

      <variablelist>
        <varlistentry>
          <term>hookobject</term>

          <listitem>
            <para>Das hook-Objekt, entweder 'item' oder 'category'</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookaction</term>

          <listitem>
            <para>Die Verwendung des Hooks. Ein Wert aus 'create', 'delete',
            'transform', oder 'display'</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookarea</term>

          <listitem>
            <para>Der Bereich des Hooks, entweder 'GUI' oder 'API'</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookmodule</term>

          <listitem>
            <para>Der Name des Moduls, das den Hook liefert</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hooktype</term>

          <listitem>
            <para>Der Names des Hook-Typs, entweder "user" oder "admin"</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookfunc</term>

          <listitem>
            <para>Der Name der Hook-Funktion</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Analog gibt es die Funktion pnModUnregisterHook, die einen
      registrierten Hook wieder entfernt. Die Parameterliste von
      pnModUnregisterHook ist identisch zu der von pnModRegisterHook.</para>

      <para>Die Hooks werden typischerweise beim Initialisieren des Moduls
      registriert und beim Löschen den Moduls aus der Datenbank wieder
      de-registriert. Für diese Vorgänge ist die pninit.php zuständig.</para>

      <para>Soll das Modul foobar einen Hook zur Verfügung stellen, der eine
      Ausgabe transformiert (also z.B. so funktioniert wie Autolinks), so
      sollte die pninit.php dieses Moduls zumindest folgenden Inhalt
      haben:</para>

      <programlisting>&lt;?php function foobar_init() { if (!pnModRegisterHook('item', 'transform', 'API', 'foobar', 'user', 'wutsch')) { pnSessionSetVar('errormsg', 'oops!'); return false; } return true; } function foobar_upgrade($oldversion) { return true; } function foobar_delete() { if (!pnModUnregisterHook('item', 'transform', 'API', 'foobar', 'user', 'wutsch')) { pnSessionSetVar('errormsg', 'oops!'); return false; } return true; } ?&gt; </programlisting>

      <para>Ruft ein Modul Hooks auf, so kann dieses Modul eine ID sowie einen
      String oder einen Array "extrainfo" übergeben. Typischerweise ist die ID
      die ID des Elements, für das die Hooks aufgerufen werden, und extrainfo
      eine Struktur, die das Element darstellt -- dies ist aber von Modul zu
      Modul verschieden!</para>

      <para>Bei obigem Beispiel wird der eigentliche Hook durch die Funktion
      wutsch (genauer: foobar_userapi_wutsch) in der pnuserapi.php
      bereitgestellt. Diese Funktion erwartet ein assiziatives Array,
      bestehend aus der ID und extrainfo, als Argument.</para>

      <para>Eine entsprechende Funktion könnte wie folgt aussehen:</para>

      <programlisting>&lt;?php function foobar_userapi_wutsch($args) { extract($args); // Argument check if ((!isset($objectid)) || (!isset($extrainfo))) { pnSessionSetVar('errormsg','oops!'); return; } if (is_array($extrainfo)) { foreach ($extrainfo as $text) { $result[] = foobar_dosomething($text); } } else { $result = foobar_dosomething($text); } return $result; } function foobar_dosomething($text) { return str_replace('foo', 'bar', $text); } ?&gt; </programlisting>

      <para>Dieses Beispiel ist natürlich ein wenig langweilig, da jeweils nur
      'foo' durch 'bar' ersetzt wird, es zeigt aber, wie Hooks zu definieren
      und einzusetzen sind.</para>
    </section>

    <section remap="h4">
      <title>Hooks verwenden</title>

      <para>Nun muß man diese Calls nur noch im eigenen Modul verknüpfen. In
      der _user_display Funktion (module/pnuser.php) fügt man dazu folgendes
      dem Ausgabeobjekt (für pnHTML-Enthusiasten auch einem
      $output-Text()-Objekt).</para>

      <para><function>pnModCallHooks('item', 'display', $id,
      pnModURL('modulename', 'user', 'display', array('id' =&gt;
      $id)))</function></para>

      <para>["id" muß dabei nur auf den jeweiligen Index gesetzt
      werden]</para>

      <para>Die Funktion hat folgende Syntax:</para>

      <para><function>pnModCallHooks(<varname>hookobject</varname>,
      <varname>hookaction</varname>, <varname>hookid</varname>,
      <varname>extrainfo</varname>); </function></para>

      <para>Die einzelnen Parameter haben die folgende Bedeutung:</para>

      <variablelist>
        <varlistentry>
          <term>hookobject</term>

          <listitem>
            <para>Das hook-Objekt, entweder 'item' or 'category'</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookaction</term>

          <listitem>
            <para>Die Verwendung des Hooks. Ein Wert aus 'create', 'delete',
            'transform', oder 'display'</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>hookid</term>

          <listitem>
            <para>Die ID des Objekts, für das der Hook ausgeführt wird (dies
            ist abhängig vom jeweiligen Modul)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>extrainfo</term>

          <listitem>
            <para>Zusätzliche Informationen für den Hook (dies ist abhängig
            von der jeweiligen "Hookaction")</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Die Funktion liefert die Ausgabe des Hooks als String
      zurück.</para>

      <para>Beim Hook-Einsatz ist Verwendung von Standard-Funktionen und
      Dateinamen obligatorisch.</para>

      <para>Für den Anfang kann man eine pnModFunc dem "Add"-Formular am Ende
      der _user_view Function hinzufügen. Die Zugriffsrechte sind in diesem
      Zusammenhang allerdings unbedingt zu beachten!</para>

      <para>Ist erst ein Modul auf diese Art programmiert, kann man nach und
      nach eine Vielzahl von Modulen zu einem komplexen Content Management
      System verknüpfen..."</para>
    </section>
  </chapter>

  <chapter>
    <title>Block Entwicklung</title>

    <para><emphasis role="bold">Einleitung</emphasis></para>

    <para>Dieses Tutorial soll nur eine kurze Einführung in das Theme der
    Block-Programmierung geben und geht nicht auf alle Feinheiten ein. Es
    sollte nach der Lektüre aber möglich sein, einen funktionierenden Block zu
    erstellen.</para>

    <para>Basiert auf dem Tutorial von J. Cox</para>

    <para><emphasis role="bold">Grundsätzliche Block
    Struktur</emphasis></para>

    <para>Am einfachsten lassen sich Blöcke erklären, wenn man sie in 3
    verschiedene Einheiten unterteilt:</para>

    <itemizedlist>
      <listitem>
        <para>Variablen</para>
      </listitem>

      <listitem>
        <para>Funktionen</para>
      </listitem>

      <listitem>
        <para>Theme Aufrufe</para>
      </listitem>
    </itemizedlist>

    <para>Jeder Block ist ungefähr gleich aufgebaut.</para>

    <para><emphasis role="bold">Variablen</emphasis></para>

    <programlisting> $blocks_modules [ 'Hello_World' ] = array( 'func_display' =&gt; 'blocks_Hello_World_block' , 'text_type' =&gt; 'Hello World' , </programlisting>

    <programlisting></programlisting>

    <programlisting>'text_type_long' =&gt; 'Hello World Block' , </programlisting>

    <programlisting></programlisting>

    <programlisting>'allow_multiple' =&gt; true , </programlisting>

    <programlisting></programlisting>

    <programlisting>'form_content' =&gt; false , </programlisting>

    <programlisting></programlisting>

    <programlisting>'form_refresh' =&gt; false , </programlisting>

    <programlisting></programlisting>

    <programlisting>'show_preview' =&gt; true ); </programlisting>

    <programlisting> </programlisting>

    <para>Dieser Teil befindet sich am Anfang jeden Blocks. Dadurch werden in
    einen Array verschiedene Einstellungen geschrieben, die dem System sagen,
    was an dem Block eingestellt werden kann.</para>

    <informaltable frame="none">
      <tgroup cols="4">
        <colspec colname="c1" colwidth="10*" />

        <colspec colname="c2" colwidth="30*" />

        <colspec colname="c3" colwidth="30*" />

        <colspec colname="c4" colwidth="30*" />

        <tbody>
          <row>
            <entry><para><emphasis role="bold"><emphasis
            role="bold">Zeile</emphasis></emphasis></para></entry>

            <entry><para><emphasis role="bold"><emphasis
            role="bold">Einträge</emphasis></emphasis></para></entry>

            <entry><para><emphasis role="bold"><emphasis
            role="bold">Beschreibung</emphasis></emphasis></para></entry>

            <entry></entry>
          </row>

          <row>
            <entry nameend="c3" namest="c1" valign="middle"><para><emphasis
            role="bold"><emphasis role="bold">Die Zeilen nochmal im
            Detail</emphasis></emphasis></para></entry>

            <entry></entry>
          </row>

          <row>
            <entry><para><literal>$blocks_modules['Hello_World'] =
            array(</literal></para></entry>

            <entry></entry>

            <entry><para>Mit dieser Zeile beginnt das Array für die
            Administration. In den eckigen Klammer steht der Name des Blocks
            (Dies ist auch der Name der entsprechenden Datei).</para> <para>
            </para></entry>
          </row>

          <row>
            <entry><para><literal>'func_display' =&gt;
            'blocks_Hello_World_block'</literal></para></entry>

            <entry></entry>

            <entry><para>Diese Zeile verweist auf die Funktion
            'blocks_statbox_blocks'.</para></entry>
          </row>

          <row>
            <entry><para><literal>'text_type' =&gt; 'Hello
            World',</literal></para> <para> <literal>'text_type_long' =&gt;
            'Hello World Block',</literal> </para></entry>

            <entry></entry>

            <entry><para>Diese Zeile legen den Namen des Blocks fest - der
            zweite Eintrag ist mehr beschreibend.</para></entry>
          </row>

          <row>
            <entry><para><literal>'allow_multiple' =&gt;
            true,</literal></para></entry>

            <entry><para>[true/false]</para></entry>

            <entry><para>Hier wird festgelegt, ob mehrere Blöcke dieses Typs
            angelegt werden dürfen. Bei dem Login-Block macht es zum Beispiel
            keinen Sinn, mehrere Blöcke zu erlauben.</para></entry>
          </row>

          <row>
            <entry><para><literal>'form_content' =&gt; false,</literal></para>
            <para> <literal>'form_refresh' =&gt; false,</literal>
            </para></entry>

            <entry><para>[true/false]</para></entry>

            <entry><para>Diese Einträge legen fest, ob der Inhalt des Blockes
            geändert werden darf und weiterhin, ob das Inhaltsformular nach
            einer Änderung aktualisiert werden soll.</para></entry>
          </row>

          <row>
            <entry><para><literal>'show_preview' =&gt;
            true</literal></para></entry>

            <entry><para>[true/false]</para></entry>

            <entry><para>Die Letzte Zeile legt fest, ob eine Vorschausicht
            möglich sein soll, oder nicht</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Der in der zweiten Zeile benutze Verweis auf eine Funktion gibt es
    noch in anderen Formen</para>

    <informaltable frame="none">
      <tgroup cols="3">
        <colspec colname="c1" colwidth="10*" />

        <colspec colname="c2" colwidth="45*" />

        <colspec colname="c3" colwidth="45*" />

        <tbody>
          <row>
            <entry><para><emphasis role="bold"><emphasis
            role="bold">Zeile</emphasis></emphasis></para></entry>

            <entry><para><emphasis role="bold"><emphasis role="bold">Funktion,
            die aufgerufen wird, wenn...</emphasis></emphasis></para></entry>

            <entry></entry>
          </row>

          <row>
            <entry><para><literal>'func_display' =&gt;
            'blocks_Hello_World_block'</literal></para></entry>

            <entry><para>...ein Block angezeigt werden soll</para></entry>
          </row>

          <row>
            <entry><para><literal>'func_update' =&gt;
            'blocks_Hello_World_update'</literal></para></entry>

            <entry><para>...ein Block geändert wurde</para></entry>
          </row>

          <row>
            <entry><para><literal>'func_add' =&gt;
            'blocks_Hello_World_add'</literal></para></entry>

            <entry><para>...ein Block angelegt wird</para></entry>
          </row>

          <row>
            <entry><para><literal>'func_edit' =&gt;
            'blocks_Hello_World_edit'</literal></para></entry>

            <entry><para>...der Inhalte eines Blocks bearbeitet werden soll.
            Meistens ist dies die umfangreichste Funktion - zumindest, wenn
            der Block nicht nur einfach Daten aus der Datenbank lesen
            soll.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <screen> </screen>

    <para><emphasis role="bold">Funktionen</emphasis></para>

    <para>Mit diesem Beispiel soll gezeigt werden, wie man die Anzahl von
    Beiträgen in einem Block anzeigt. Das ist eine einfache Funktion, die aber
    das Konzept der Blöcke verdeutlichen kann. Sie ist einer Funktion top_list
    entnommen, die ursprünglich von Francisco Burzi für die Benutzung in
    PHPNuke geschrieben wurde. In dieser Form ist sie allerdings ungetestet
    und sollte nur als Demonstration gesehen werden.</para>

    <screen> <literal> </literal><literal>function block_Hello_World_block($row) { // Hier finden die Schritte zur Zusammenstellung // des Blockinhalts statt. // Titel des Blocks. Normalerweise sollte der nicht // verändert werden, da bereits vom Admin vorgegeben $row['title'] = 'Hello World'; // Inhalt des Blocks $row['content'] = 'Dies ist der Inhalt des Blocks'; // Block ausgeben themesideblock($row); }</literal><literal></literal> </screen>

    <para>Der Name der Funktion ist der gleiche, der im eben beschriebenen
    Teil eingeführt wurde. (Zur Erinnerung: 'func_display' =&gt;
    'blocks_Hello_World_block',)</para>

    <para>Mit den drei Zeilen mit dem Aufruf von themesideblock:</para>

    <screen> <literal> $row['title'] = 'Hello World'; $row['content'] = 'Dies ist der Inhalt des Blocks'; themesideblock($row);</literal> </screen>

    <para>An dieser Stelle wird der gesamte Inhalt für die Anzeige im Theme
    bereitgestellt. Blöcke mit dem themesideblock Aufruf sind können ebenfalls
    von PHPNuke Themes verstanden werden.</para>

    <para>Gute Informationen in Französisch zum Thema: <ulink url="#">bei
    boomtchak</ulink>.</para>
  </chapter>

  <chapter>
    <title>Coding Richtlinien</title>

    <para>Beim Erstellen von Modulen und Blöcken bzw. auch bei Bugfixes
    sollten einige Richtlinien beachtet werden:</para>

    <itemizedlist>
      <listitem>
        <para>Prüfung von an Funktionen übergebenen Werten - z.B. dass $sid,
        $catid, $tid, etc. wirklich numerisch sind mit der is_numeric()
        Funktion.</para>

        <para>Diese bedeutet Abfragen wie if (empty($sid) || !is_numeric($sid)
        || ...) {</para>
      </listitem>

      <listitem>
        <para>Korrekter Gebrauch von pnVarPrepForStore() - die jeweiligen
        Werte gehören *in* Anführungszeichen</para>

        <para>Dies bedeutet Statements wie: $query .= " AND
        $columndef['thiscolumn'] = '" . pnVarPrepForStore($myval) .
        "'";</para>
      </listitem>

      <listitem>
        <para>Jegliche Ausgabe nur über die entsprechenden
        pnVarPrepForDisplay($myvar); Funktionen sowie Formulareingaben über
        pnSecGenAuthKey() abprüfen.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">keine globalen Variablen</emphasis>
        benutzen (neuere PHP-Versionen haben register_globals=off
        gesetzt)</para>
      </listitem>

      <listitem>
        <para>von PostNuke <emphasis role="bold">reservierte Namen/Funktionen
        nicht redklarieren</emphasis></para>
      </listitem>

      <listitem>
        <para>Operationen durch <emphasis
        role="bold">pnSecAuthAction()</emphasis> absichern</para>
      </listitem>

      <listitem>
        <para>Formulareingaben durch <emphasis
        role="bold">pnSecConfirmAuthKey()</emphasis> absichern</para>
      </listitem>

      <listitem>
        <para>übergebene Variablen durch <emphasis
        role="bold">pnVarCleanFromInput()</emphasis> prüfen</para>
      </listitem>

      <listitem>
        <para>jegliche Ausgabe über <emphasis
        role="bold">pnVarPrepForDisplay()</emphasis> bzw. <emphasis
        role="bold">pnVarPrepHTMLDisplay()</emphasis> parsen</para>
      </listitem>

      <listitem>
        <para>wenn notwendig die Ausgabe über <emphasis
        role="bold">pnVarCensor()</emphasis> laufen lassen</para>
      </listitem>

      <listitem>
        <para>Variablen in SQL-Abgfragen mit <emphasis
        role="bold">pnVarPrepForStore()</emphasis> angeben</para>
      </listitem>

      <listitem>
        <para>Variablen für Zugriffe auf das Dateisystem mit <emphasis
        role="bold">pnVarPrepForOS()</emphasis> angeben</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">pnModCallHooks()</emphasis> nutzen wenn
        möglich.</para>
      </listitem>
    </itemizedlist>

    <para>Die (englischsprachigen) PostNuke-Coding-Richtlinien sind bei <ulink
    url="http://noc.postnuke.com/docman/view.php/5/1/PostNuke%20Coding%20Standards.htm">noc.postnuke.com</ulink>
    zu finden. Allgemeine (englischsprachige) Coding-Richtlinien finden sich
    z.b. bei <ulink
    url="http://pear.php.net/manual/en/standards.php">PEAR</ulink> und vom
    <ulink url="http://utvikler.start.no/code/php_coding_standard.html">DB
    Medialab</ulink>.</para>
  </chapter>

  <chapter>
    <title>PostNuke ADODB Dokumentation</title>

    <para>Diese Dokumentation basiert auf dem englischsprachigen Original von
    Pablo Roca (<ulink
    url="mailto:pabloroca@mvps.org">pabloroca@mvps.org</ulink>) vom November
    22th, 2001 (Release 1.3)</para>

    <para>Es stellt eine Einführung in die Arbeit mit der ADODB, wie sie seit
    Postnuke 0.7 benutzt wird, dar. Pablo hat dabei einige Teile der
    originalen ADODB-Dokumentation benutzt. Als erstes ist sicher zu stellen,
    daß Deine Site mindestens unter PHP 4.01 pl2 (wegen der Unterstützung von
    require_once und include_once) läuft.</para>

    <para>Obwohl ADODB eine Vielzahl Datenbanksysteme unterstützen soll, kann
    aufgrund der Unterschieden zwischen den verschiedenen Systemen bislang nur
    an der Umsetzung für MySQL, PostgreSQL, MSSQL , Oracle und ODBC gearbeitet
    werden. Ist dies getan, sollen weitere Systeme folgen.</para>

    <para>Dank gilt:</para>

    <para>John Lim (ADODB Entwickler) für das programmieren einer coolen
    Bibliothek und für die Vorschläge und Tipps</para>

    <para>David Sedeno, der ADODB unter Postgres getestet hat</para>

    <para>Tim Litwiller, Tester für MySQL</para>

    <para>Carlos Merino, für MSSQL</para>

    <para>Jim McDonald für die lange, coole, technische Diskussion</para>

    <para>Pascal Riva, für seinen Support</para>

    <para>Im folgenden nehmen wir folgendes an:</para>

    <para>$dbconn - ist das Objekt, das mit der Datenbank verbunden ist</para>

    <para>$result - ist das Recordset mit dem Ergebnis einer Abfrage</para>

    <para><emphasis role="bold">1. Das Öffnen einer
    Datenbank</emphasis></para>

    <para>Das kann man sich zwar in Postnuke schenken, weil das schon vom
    Postnuke-Core gemacht wird, aber der Vollständigkeit halber:</para>

    <screen> GLOBAL $ADODB_FETCH_MODE; $ADODB_FETCH_MODE = ADODB_FETCH_NUM; $dbconn = &amp;ADONewConnection($pnconfig[dbtype]); $dbh = $dbconn-&gt;Connect($pnconfig[dbhost],$pnconfig[dbuname],$pnconfig\ [dbpass],$pnconfig[dbname]); if ($dbh === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databas\ e"); } </screen>

    <para><emphasis role="bold">2. Fehler</emphasis></para>

    <para>Normalerweise würde man wohl die ErrorNo()-Funktion benutzen, doch
    einige Datenbanksysteme wie zum Beispiel ODBC vor PHP 4.0.6, PostgresSQL
    und Interbase geben keinerlei Wert zurück. In anderen Fällen wird einfach
    die letzte ErrorNo() zurpckgegeben.</para>

    <blockquote>
      <para><emphasis role="bold">John Lim:</emphasis> "<emphasis>In den
      meinsten Fällen bedeuten Datenbank-Fehler einfach: a. Die Datenbank ist
      überhaupt nicht erreichbar b. Die Verbindungsdaten sind falsch c. Eine
      Tabelle fehlt d. The Feldnamen sind falsch e. Die SQL-Syntax ist
      inkorrekt f. Die Datenbank ist voll g. Die Datenbank ist
      schreibgeschützt In den Fällen (a) oder (b) reicht es dem User eine
      Meldung zu schicken, die ihm hilft die Verbindung herzustellen. Die
      weitere Ausführung der Seite macht keinen Sinn und sollte stoppen. Bei
      (c), (d) und (g) handelt es sich höchstwahrscheinlich um
      Installationsprobleme, bei dem eine sinnvolle Fehlerausgabe den größten
      Effekt hat. Auch hier macht die weitere Ausführung der Seite keinen Sinn
      und sollte stoppen.</emphasis></para>

      <para><emphasis>(e) resultiert aus Programmierfehlern. Wieder hilft eine
      sinnvolle Fehlerausgabe. Auch sollte die Ausführung der Seite
      stoppen.</emphasis></para>

      <para><emphasis>Unter der Vorraussetzung, daß alle ADODB-Funktionen bei
      einem Fehler eine False-Wert zurück geben hat sich die konkrete
      Fehlernummer in den meisten Fällen als wenig informativ
      erwiesen.</emphasis>"</para>
    </blockquote>

    <para>Nichtsdestoweniger wird ErrorNo(), falls vorhanden, natürlich die
    letzte Fehlernummer zurückgeben:</para>

    <screen> if ($dbconn-&gt;ErrorNo()&lt;&gt;0) { die("Error accesing to the database " . $dbconn-&gt;ErrorNo() . ""); } </screen>

    <para>ErrorMsg() gibt immer den letzten Status oder die letzte
    Fehlermeldung als String zurück - sogar wenn gar kein Fehler ausgetreten
    ist. Mit ErrorNo() läßt sich das überprüfen:</para>

    <screen> if($dbconn-&gt;ErrorNo()&lt;&gt;0) { die("Error accesing to the database " . $dbconn-&gt;ErrorNo() . ": " \ . $dbconn-&gt;ErrorMsg() . ""); } </screen>

    <para>Für Postnuke wird folgendes Vorgehen vorgeschlagen:</para>

    <screen> $sql = "SELECT bid, name, title FROM mytable"; $result = $dbconn-&gt;Execute($sql); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); }if (!$result-&gt;EOF) ......... </screen>

    <para>PN_DBMsgError übernimmt 4 Parameter: Das Datenbank-Objekt, __FILE__
    für die Behandlung des Programmnamens, __LINE__ mit der fehlerhaften Zeile
    und die eigentliche Fehlermeldung. Die Meldung ist aber optional,
    standartmäßig wird der Fehler "Error accesing to the database" ausgegeben.
    Bedenke, daß die PN_DBMsgError die Ausführung mit einem "die" stoppt. Zum
    debuggen kannst Du vorübergehend $dbconn-&gt;debug = true setzen - die
    ADODB-Fehler werden dann direkt ausgegeben.</para>

    <para><emphasis role="bold">3. SELECTs und UPDATEs</emphasis></para>

    <para><emphasis role="bold">3.1 Execute($sql,
    inputarr=false)</emphasis></para>

    <para>Execute() führt einen SQL-Befehl aus und gibt bei Erfolg ein
    Recordset zurück. Es wird immer, auch bei INSERTs und UPDATEs ein
    Recordset zurückgegeben. "False" wird nur bei einem Fehler
    zurückgeben.</para>

    <para>Das $inputarr-Parameter kann auch mit Variablen-Binding genutzt
    werden. Das beschleunigt die Kompliation und das Caching der SQL-Abfragen,
    was zu einer besseren Performance führt. Zur Zeit unterstützen Oracle und
    ODBC Variablen-Binding. (In Postnuke findet diese Technik keine
    Verwendung)</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT bid, name, title FROM mytable"); $result = $dbconn-&gt;Execute("INSERT INTO mytable (bid, name, title) VALUE\ S (1,'john doe', 'manager'"); </screen>

    <para><emphasis role="bold">3.2
    SelectLimit($sql,$numrows=-1,$offset=-1,$inputarr=false)</emphasis></para>

    <para>SelectLimit($sql,$numrows=-1,$offset=-1,$inputarr=false) gibt bei
    Erfolg ein recordset, bei Mißerfolg "False" zurück. In MySQL kann man mit
    Limit die Anzahl der anzuzeigenden Reihen begrenzen. Limit benötigt dazu
    zwei numerische Variablen - die erste spezifiziert die erste Reihe, aber
    der gezählt werden soll, die zweite Variable beschreibt die Anzahl der zu
    zeigenden Reihen. Gibt man nur einen Wert an, ist das die Anzahl der
    Reihen, standartmäßig wird dann von Reihe 0 (nicht 1) ausgegangen:</para>

    <screen> select * from table LIMIT 5,10; # ergibt Reihe 6-15 </screen>

    <screen> select * from table LIMIT 5; # ergibt die ersten 5 Reihen </screen>

    <screen> $connection-&gt;SelectLimit('SELECT * FROM TABLE',-1,10) # ergibt die letzt\ en 11 Reihen. </screen>

    <para>Der dritte Variable ist nur für Datenbanksysteme mit
    Variablen-Binding-Unterstützung gedacht. Das verringert den
    SQL-Kompilations Overhead gewaltig. Ein Oracle-Beispiel hierfür:</para>

    <screen> $conn-&gt;SelectLimit("SELECT * FROM TABLE WHERE COND=:val", 100,-1,array('\ val'=&gt; $val)); </screen>

    <para><emphasis role="bold">4. Close()</emphasis></para>

    <para>Close() schließt ein Recordset und/oder eine Datenbank-Verbindung.
    PHP4 aber rühmt sich einer eigenen Funktion, die ein solches Aufräumen
    obsolet macht.</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT count(*) AS count FROM banner"); ... $result-&gt;Close(); </screen>

    <para><emphasis role="bold">5. Numerische Autoincrement Felder erzeugen
    (GenID &amp; PO_Insert_ID)</emphasis></para>

    <para>Nicht in allen Datenbanksystemen gibt es eine
    Autoincrement-Funktion. Für diejenigen, die das nicht unterstützen muß der
    Programmierer diese Arbeit übernehmen. In ODBC zum Beispiel gibt es diese
    Funktion nicht.</para>

    <para>Ein weiteres Problem ist zu wissen, welche ID eingefügt wurde. Auf
    den ersten Blick würden man zur Insert_ID() greifen - die wird aber nur
    von MySQL, PostgreSQL und MSSQL, nicht aber von ODBC, Oracle und anderen
    unterstützt. Ein Workaround ist also nötig. Dazu wurde die PO_Insert_ID()
    zusammengehackt.</para>

    <para>Wie ist diese zu nutzen? Es gibt 2 Fälle:</para>

    <para><emphasis role="bold">5.1 Der Normalfall</emphasis></para>

    <para>Die ID wird vom Datenbanksystem erzeugt und nach einem INSERT müssen
    wir gar nicht wissen, welche ID vergeben wurde.</para>

    <screen> uid = $dbconn-&gt;GenId('users'); $result = $dbconn-&gt;Execute("INSERT INTO users (uidfield, ..) VALUES \ ($uid, ...)"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } </screen>

    <para><emphasis role="bold">5.2 Bei Fremdschlüsseln oder dem späteren
    Gebrauch von generierten IDs</emphasis></para>

    <para>Die ID wird widerum im Datenbanksystem erzeugt, nach dem INSERT
    brauchen wir die neue ID aber um zum Beispiel einen Fremdschlüssel
    (Foreign Key) zu bearbeiten. So kann man sich ein SELECT MAX() sparen -
    zur Zeit ist das aber Zukunftsmusik.</para>

    <screen> $uid = $dbconn-&gt;GenId('users'); $result = $dbconn-&gt;Execute("INSERT INTO users (uidfield, ..) VALUES \ ($uid, ..)"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $uid = $dbconn-&gt;PO_Insert_ID("users","uidfield"); </screen>

    <para>PO_Insert_ID() benötigt zwei Werte: Den Namen der Tabelle und den
    Namen des autoincrement-Feldes. Diese Feld muß in der Tabelle ein Index
    sein.</para>

    <para>Der Trick besteht einfach darin nach einem INSERT ein SELECT MAX()
    auszuführen, um die letzte eingefügte ID zu bekommen. Wenn Du keine
    generierte ID brauchst, solltest du das aber nicht machen. Datenbanken,
    die ihre letzte generierte ID nicht kennen (MySQL, PostgreSQL und MSSQL
    können das) und in Umgebungen mit vielen Datenbankzugriffen kann man so
    einen falschen Wert bekommen. Auf jeden Fall solltest Du dieses Sache vor
    der Veröffentlichung ausgibig testen.</para>

    <para><emphasis role="bold">6. Affected_Rows( )</emphasis></para>

    <para>Diese Funktion gibt die Anzahl der von einem UPDATE oder DELETE
    betroffenen Zeilen. "False" wird nur zurückgegeben, wenn das DBS diese
    Funktion nicht unterstützt.</para>

    <screen> $result = $dbconn-&gt;Execute("UPDATE session SET time='$ctime', host_addr=\ '$ip' WHERE username='$username'"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } // if no update is done if ($dbconn-&gt;Affected_Rows() &lt;= 0) { $result = $dbconn-&gt;Execute("INSERT INTO session (username, time, host\ _addr, guest) VALUES ('$username', '$ctime', '$ip', '$guest')"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } } </screen>

    <para><emphasis role="bold">7. Ergebnisse eines SELECTs zählen mit
    RecordCount()</emphasis></para>

    <para>Es gibt die RecordCount() Funktion, die uns die Anzahl der
    Ergebnisse in einem Recordset zurückgibt. Für DBS'e wie Oracle, die dieses
    Feature nicht unterstützen gibt es einen Workaround.</para>

    <para>Wieder gibt es 2 Szenarien:</para>

    <para><emphasis role="bold">7.1 Enthält das Recordset überhaupt
    Werte?</emphasis></para>

    <para>Mit $result-&gt;EOF läßt sich diese Funktion absichern:</para>

    <screen> $sql = "SELECT bid, name, title FROM mytable"; $result = $dbconn-&gt;Execute($sql); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } if ($result-&gt;EOF){ echo "the SELECT returned no records"; } else { echo "the SELECT returned records"; } </screen>

    <para><emphasis role="bold">7.2 wir brauchen die Anzahl der Ergebnisse für
    spätere Operationen.</emphasis></para>

    <para>PNRecordCount() wurde zur Behandlung aller möglichen DBS'e, die
    keinen nativen RecordCount-Support haben, geschrieben.</para>

    <screen> $sql = "SELECT bid, imageurl, clickurl FROM banner WHERE cid=$cid"; $result = $dbconn-&gt;Execute ($sql); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $recordcount = $result-&gt;PO_RecordCount("banner","cid=$cid"); ... </screen>

    <para>PNRecordCount() benötigt zwei Werte: Den Tabellennamen und die
    SELECT-Bedingung. Indizierte Felder beschleunigen den Zugriff.</para>

    <para>Anmerkung: Sollte Deine Datenbank RecordCount nicht unterstützen, so
    wie access, ado, ado-access, vfp, interbase, Oracle und einige
    ODBC-Versionen, dann wirst Du einige Performance-Einbußen hinnehmen
    müssen. John Lim meint zum Beispiel zu diesem Thema: "<emphasis>Dieses
    Vorgehen wir in Umgebungen mit viel Traffic mit vielen gleichzeitigen
    UPDATEs und DELETEs zu falschen Ergebnissen führen. Da ADODB SQL-Befehle
    nicht interpretieren kann, wäre es fatal SELECT COUNT(*) zu
    emulieren.</emphasis>"</para>

    <para><emphasis role="bold">8. MoveNext()</emphasis></para>

    <para>MoveNext() rückt den internen Zeiger in die nächste Reihe. Das
    Felder-Array wird automatisch aktualisiert. Sollte die Aktion nicht
    möglich sein, wird "False" zurückgegeben. Wenn Du EOF bis, dann ist
    $result-&gt;EOF "true".</para>

    <screen> while (!$result-&gt;EOF){ $var = $result-&gt;fields[0]; echo $var; ... $result-&gt;MoveNext(); } </screen>

    <para>oder besser:</para>

    <screen> for(;!$result-&gt;EOF;$result-&gt;MoveNext() ) { $var = $result-&gt;fields[0]; echo $var; ... } </screen>

    <para><emphasis role="bold">9. Daten abfragen</emphasis></para>

    <para>Nach einem SELECT gibt es verschiedene Möglichkeiten die Daten, die
    im $result-&gt;fields Array gelandet sind, abzufragen. An dieser Stelle
    werden nur die zwei gängigsten Methoden vorgestellt. In Rekursionen und
    Schleifen arbeiten wir mit einem MoveNext(), da dies nicht automatisch
    passiert.</para>

    <para>Obwohl ab ADODB 1.52 (Dez. 2002: v2.50, enthalten ab pn .722) die
    Funktion FetchRow() (wie in PEAR) enthalten ist, darf diese nicht benutzt
    werden, da sie selbstständig einen MoveNext() vornimmt, was aber bei einer
    $result-&gt;EOF-Abfrage an späterer Stelle Probleme gibt.</para>

    <para><emphasis role="bold">9.1. Numerische Array
    (Skalare)</emphasis></para>

    <para>Diese Art des Vorgehens ist empfohlen - man zeigt einfach direkt auf
    ein Feld des Arrays.</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $userinfo = $result-&gt;fields; ... </screen>

    <para>Das hier wird aber auch funktionieren:</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $userinfo[0] = $result-&gt;fields[0]; $userinfo[1] = $result-&gt;fields[1]; ... </screen>

    <para><emphasis role="bold">9.2 Variablen (keine Arrays)</emphasis></para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } list($name, $lastname) = $result-&gt;fields; ... </screen>

    <para>Oder so:</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $name = $result-&gt;fields[0]; $lastname = $result-&gt;fields[1]; .... </screen>

    <para>Beides weißt den Variablen $name und $lastname die ersten zwei
    Array-Werte zu.</para>

    <para><emphasis role="bold">9.3. Inhaltsorientierte
    Arrays</emphasis></para>

    <para>Diese Art die Daten zu übernehmen sollte vermieden werden, da sie
    nicht so performant ist und es dazu einen Fehler in MySQL gibt. Falls es
    sich nicht umgehen läßt, sollte man trotzdem in Skalaren denken.</para>

    <para>In diesem Fall benutzen wir die GetRowAssoc(false) Funktion, die
    einen assoziativen Array mit den Daten der aktuellen Zeile zurückgibt. Die
    Array-Schlüssel entsprechen den Feldbezeichnungen der Datenbank in
    Kleinschreibung. Um die nächste Zeile auszulesen, benutzen wir wieder
    MoveNext().</para>

    <screen> result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $userinfo = $result-&gt;GetRowAssoc(false); ... </screen>

    <para>Oder:</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } $userinfo['name'] = $result-&gt;fields[0]; $userinfo['lastname'] = $result-&gt;fields[1]; ... </screen>

    <para>Das ergibt dann $userinfo['name'] und $userinfo['lastname'].</para>

    <para><emphasis role="bold">10. Schleifen</emphasis></para>

    <para>Abhängig von der Art der Daten, die zurück gegeben werden, kommt
    einer der folgenden Fälle zum Einsatz:</para>

    <para>Variablen:</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users");if ($r\ esult === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } for(;!$result-&gt;EOF;$result-&gt;MoveNext() ) { list($name,$lastname)=$result-&gt;fields; ... } </screen>

    <para><emphasis role="bold">numerische Arrays (Sklare)</emphasis></para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users");if ($r\ esult === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } for(;!$result-&gt;EOF;$result-&gt;MoveNext() ) { $userinfo=$result-&gt;fields; ... } </screen>

    <para><emphasis role="bold">Assioziative Arrays</emphasis></para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if($dbconn-&gt;ErrorNo()&lt;&gt;0) { die("Error accesing to the database " . $dbconn-&gt;ErrorNo() . ": " \ . $dbconn-&gt;ErrorMsg() . ""); } for(;!$result-&gt;EOF;$result-&gt;MoveNext() ) { $userinfo = $result-&gt;GetRowAssoc(false); ... } </screen>

    <para>Wenn Du die While-Schleife bevorzugst, vergiß nicht, am Ende der
    Schleife das MoveNext() zu setzen:</para>

    <screen> $result = $dbconn-&gt;Execute("SELECT name, lastname FROM users"); if ($result === false) { PN_DBMsgError($dbconn, __FILE__, __LINE__, "Error accesing to the databa\ se"); } while (!$result-&gt;EOF) { $userinfo = $result-&gt;GetRowAssoc(false); ... $result-&gt;MoveNext(); } </screen>

    <para><emphasis role="bold">11. Daten in die Datenbank
    schreiben</emphasis></para>

    <para>Da einige Datenbanksysteme keine Kurzsyntax verstehen, müssen alle
    INSERTS in vollen SQL-Befehlen ausgeführt werden. Zum Beispiel würde
    folgendes <emphasis role="bold">nicht</emphasis> funktionieren:</para>

    <screen> $sql = "INSERT INTO mytable VALUES ('John Doe', 'Spain', 23)"; $result = $dbconn-&gt;Execute($sql); </screen>

    <para>Besser ist es so:</para>

    <screen> $sql = "INSERT INTO mytable (name, country, age) VALUES ('John Doe', 'Spain\ ', 23)"; $result = $dbconn-&gt;Execute($sql); </screen>

    <para><emphasis role="bold">12. INSERTs und UPDATEs und die
    Datentypen</emphasis></para>

    <para>Nehmen wir an, Du willst folgendes in die Datenbank
    schreiben:</para>

    <para>ID=3</para>

    <para>TheDate=mktime(0,0,0,8,31,2002) /* 31. August 2002 */</para>

    <para>Note=Süße, warum blasen wir es nicht ab</para>

    <para>Auf verschiedenen DBS'en gibt es hierbei Probleme. Es fängt schon
    damit an, daß die Systeme verschiedene Formate für das Datum benutzen. So
    erwartet MySQL das YYYY-MM-DD Format, während andere DBS'e ganz andere
    Formate haben. ADODB unterstützt dazu die Funktion DBDate(), die das Datum
    ins jeweils richtige Format konvertiert.</para>

    <para>Das nächste Problem ist, daß die Notiz (Note) in Anführungsstrichen
    stehen muß - zumindest in MySQL, andere Datenbanksysteme wie Sybase,
    Access, und MSSQL-Server brauchen das nicht. Um auch hier DBS-unabhängig
    zu programmieren, gibt es die qstr() (quotestring) Funktion:</para>

    <screen> $sql = "INSERT INTO table (id, thedate,note) values (" . $ID . ',' . $dbconn-&gt;DBDate($TheDate) .',' . $dbconn-&gt;qstr($Note).")"; </screen>

    <screen> $result = $dbconn-&gt;Execute($sql); </screen>

    <para>Achtung: Wenn magic_quotes eingeschaltet sind, können auch in der
    qstr()-Funktion noch zusätzliche Anführungszeichen eingefügt werden. Um
    dies zu verhindern müssen magic_quotes an dieser Stelle ausgeschaltet
    werden:</para>

    <screen> $this-&gt;qstr($var, $is_magic_quotes_on); </screen>

    <para><emphasis role="bold">13. DBS-spezifische
    Funktionen</emphasis></para>

    <para>Bei der DBS-unabhängigen Programmierung muß darauf geachtet werden,
    daß DBS-spezifische Funktionen nicht genutzt werden. In PostNuke wurde zum
    Beispiel die UNIX_TIMESTAMP-Funktion, die nur MySQL unterstützt, durch die
    gleichnamige Funktion aus der ADODB ersetzt. Zum Beispiel:</para>

    <para><emphasis role="bold">Schlecht:</emphasis></para>

    <screen> $sql ="SELECT UNIX_TIMESTAMP(datefield) AS unix_date FROM authors ... OR\ DER BY unix_date .."; $result = $dbconn-&gt;Execute($sql); </screen>

    <para><emphasis role="bold">Besser:</emphasis></para>

    <screen> $sql ="SELECT datefield AS unix_date FROM authors ... ORDER BY unix_date \ .."; $result = $dbconn-&gt;Execute($sql); ... $thedate = $result-&gt;UnixTimeStamp($result-&gt;fields[0]); </screen>

    <para><emphasis role="bold">13. Debugging</emphasis></para>

    <para>In Postnuke gibt es verschiedene Möglichkeiten der Fehlersuche. Dazu
    läßt sich LensDebug (von John Lim - Original (c) by DATABAY AG 2001 -
    ay@databay.de) integrieren. In der config.php müssen dazu nur 2
    zusätzliche Variablen eingetragen werden.</para>

    <para>$debug - der Wert 1 sorgt dafür, daß die Anzahl der SQL-Befehle und
    die Renderzeit angegeben wird.</para>

    <para>$debug-sql - Hier ist der Wert 1 nur sinnvoll, wenn $debug auch auf
    1 steht. Dann werden die SQL-Befehle einzelnd ausgegeben. Um auch die
    Variablen und Messages im Debug-Fenster auszugeben, benötigst Du nur
    folgendes:</para>

    <screen> GLOBAL $dbg; $dbg-&gt;v($var1,"var1"); // display a variable and its type $dbg-&gt;msg('Show a text message'); </screen>

    <para>Nur beim senden von Headern wird es hier Probleme geben.</para>

    <para>Um die Renderzeit in der Site selbst anzuzeigen, mußt Du in der
    footer.php nach der printf (um die Zeile 70) suchen und die
    Auskommentierung entfernen.</para>

    <para>Auch in der ADODB kannst Du mit dbconn-&gt;debug = true zeitweilig
    die ADODB-Fehler ausgeben lassen.</para>

    <para><emphasis role="bold">Bitte benutze keine Funktionen, die in diesem
    Text nicht empfohlen sind!</emphasis></para>
  </chapter>

  <chapter>
    <chapterinfo>
      <author>
        <firstname>Mark</firstname>

        <surname>West</surname>
      </author>

      <copyright>
        <year>2004</year>

        <holder>Mark West</holder>
      </copyright>

      <legalnotice>
        <para>Erlaubnis zum kopieren, verteilen und/oder ändern dieses
        Dokumentes im Sinne der freien GNU Lizenz, Version 1.2, oder jeder
        neueren Version, die durch die Free Software Foundation veröffentlicht
        wird.</para>

        <para>Eine Kopie der Lizenz kann man bei der <ulink
        url="http://www.gnu.org/licenses/fdl.txt">Free Software
        Foundation</ulink> erhalten.</para>
      </legalnotice>
    </chapterinfo>

    <title><anchor id="dbdoclet.id.d0e1" />pnHTML basierende Module nach
    pnRender umwandeln</title>

    <para>Diese Dokumentation ist nicht als entgültiges HOWTO gedacht um
    Module die pnHTML benutzen nach pnRender umzuwandeln, aber es versucht ein
    paar Ratschläge, Tipps und Richtlinien zuzeigen, die ein Entwickler
    befolgen kann, wenn er von einer Ausgabemethodologie zur anderen wechselt.
    Diese Dokumentation ist weder eine Endausgabe noch eine
    Anfängerbeschreibung. Diese Dokumentation setzt voraus, das die Person die
    sich mit ihr befasst mit dem Code von pnHTML und mit der Architektur von
    pnRender vertraut ist.</para>

    <para>Diese Tipps basieren auf monatelanger Arbeit mit pnRender während
    die Kern-Module für PN .8 übertragen wurden.</para>

    <para>Das Beispielmodul ist für Entwickler bestimmt als eine Demonstration
    zum Schreiben von API kompatiblen Modulen mit pnRender als auch der
    Ausgabemethodologie. Seitdem die Methodologie konstant weiterentwickelt
    wird, ist es von Vorteil das CVS nach diesem Modul und nach neusten Code's
    und Tamplates, die bis jetzt noch nicht freigegeben sind, zu durchsuchen.
    CVS für das Beispielmodul kann bei <ulink
    url="http://cvs.postnuke.com/viewcvs.cgi/PostNuke/Modules/Miscellaneous/Example/">http://cvs.postnuke.com/viewcvs.cgi/PostNuke/Modules/Miscellaneous/Example/</ulink>
    gefunden werden.</para>

    <section remap="h2">
      <title><anchor id="dbdoclet.id.pnrender_intro" />1. pnHTML basierende
      Module nach pnRender umwandeln</title>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.pnrender_intro_avail" />1.1. Beginne
        mit der Administration</title>

        <para>Da dies einfach in andere Templates einbezogen wird, ist dies
        eine guter Anfang. Nimm eine Kopie des Administrationsmenüstemplate
        vom Beispielmodul. Dann editiere dieses durch ersetzen der
        Funktionsnamen und Sprachkonstanten.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e89" />1.2. Erstelle ein
        Administrations Template</title>

        <para>Da dies einfach in andere Templates einbezogen wird, ist dies
        eine guter Anfang. Nimm eine Kopie des Administrationsmenüstemplate
        vom Beispielmodul. Dann editiere dieses durch ersetzen der
        Funktionsnamen und Sprachkonstanten.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e94" />1.3. Entferne die
        Administrationsmenüfunktionen und Funktionsabfragen aus der
        pnadmin.php</title>

        <para>Jetzt entferne alle Spuren der alten
        Administrationsmenüfunktionen aus dem phpCode. Es wird zwei Abschnitte
        hier geben; erstens die Administrationsmenüfunktion selbst d.h.
        "example_adminmenu" und der Anruf für diese Funktion in allen anderen
        GUI-Funktionen.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e99" />1.4. Entfernen der pnHTML
        Bestandteile aus den Fehlermeldungen</title>

        <para>Wir entfernen pnHTML Bestandteile aus allen Fehlermeldungen, um
        das Modul etwas zu vereinfachen. Code wie</para>

        <screen>if (!pnSecAuthAction(0, 'Example::Item', '::', ACCESS_EDIT)) { $output-&gt;Text(_EXAMPLENOAUTH); return $output-&gt;GetOutput(); } </screen>

        <para>wird zu</para>

        <screen>if (!pnSecAuthAction(0, 'Example::Item', '::', ACCESS_EDIT)) { return pnvarPrepHTMLDisplay(_EXAMPLENOAUTH); } </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e109" />1.5. Ändern der
        Objekt-Ausgabe</title>

        <para>Jetzt übertrage die Erzeugung eines pnHTML Objekts auf ein
        pnRender Objekt. Codeverbindung wie</para>

        <screen>// Create output object - this object will store all of our output so t\ hat // we can return it easily when required $output = new pnHTML(); </screen>

        <para>wird zu</para>

        <screen>// Create output object - this object will store all of our output so t\ hat // we can return it easily when required $pnRender =&amp; new pnRender(); </screen>

        <para>Die Verwendung von "&amp;" ist wichtig weil es den zusätzlichen
        Speicherbedarf der Anwendung reduziert. Der alte HTML Stil schuf eine
        Zweitausfertigung der pnHTML Klasse für unser Modul. Das "&amp;" zeigt
        an, daß ein Verweis auf die pnRender Klasse geschaffen und die ganze
        Klasse im Speicher auf diese Art nicht dupliziert wird.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e122" />1.6. Zwischenspeichern in der
        Administration</title>

        <para>Für die Administration ist es wahrscheinlich, das nicht
        zwischengespeichert wird, sodaß wir das Zwischenspeichern in der
        Administration abstellen, d.h.</para>

        <screen> // As Admin output changes often, we do not want caching. $pnRender-&gt;caching = false; </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e129" />1.7. Ändern aller
        Anfangsblöcke</title>

        <para>Alle Administrationsseiten haben eine Serie von Anfangsblöcken,
        so daß wir diesen erst übertragen.</para>

        <para>Wir haben den Administrationsmenücode in Abschnitt 1.3 schon
        entfernt, sodass wir erst das Menü des Templates hinzufügen.</para>

        <para>Code:</para>

        <screen> &lt;!--[include file="example_admin_menu.htm"]--&gt; </screen>

        <para>Jede Seite sollte einen Titel haben, der dem Benutzer zeigt,
        welche Funktion gerade im Modul arbeitet.</para>

        <para>Code:</para>

        <screen> // Title - putting a title ad the head of each page reminds the user wh\ at // they are doing $output-&gt;Title(_EXAMPLEEDIT); </screen>

        <para>wird zu</para>

        <para>Template:</para>

        <screen> &lt;div class="pn-title"&gt;&lt;!--[pnml name="_EXAMPLEEDIT"]--&gt;&lt;\ /div&gt; </screen>

        <para>Jede Seite, die ein Formular enthält, hat einen
        Formularüberschrift. Diese Überschrift enthält die Ziel-URL.</para>

        <para>Code:</para>

        <screen> // Start form - note the use of pnModURL() to create the recipient URL \ of // this form. All URLs should be generated through pnModURL() to ensur\ e // compatibility with future versions of PostNuke $output-&gt;FormStart(pnModURL('Example', 'admin', 'create')); </screen>

        <para>wird zu</para>

        <para>Template:</para>

        <screen> &lt;form action="&lt;!--[pnmodurl modname="Example" type="admin" func="crea\ te"]--&gt;" method="post" enctype="application/x-www-form-urlencoded"&gt; </screen>

        <para>Jede Seite, die eine Formular enthält, erfordert eine
        Formularauthorisationskennung.</para>

        <para>Code:</para>

        <screen> // Add an authorisation ID - this adds a hidden field in the form that // contains an authorisation ID. The authorisation ID is very importan\ t in // preventing certain attacks on the website $output-&gt;FormHidden('authid', pnSecGenAuthKey()); </screen>

        <para>wird zu</para>

        <para>Template:</para>

        <screen> &lt;input type="hidden" name="authid" value="&lt;!--[pnsecgenauthkey modu\ le="Example"]--&gt;"&gt; </screen>

        <para><emphasis>Merke:</emphasis> wir haben den Modulnamen hier
        hinzugefügt - pnSenGenAuthKey braucht einen (optionalen) Parameter,
        sodass Module beginnen sollte diese Prameter aktiver zu machen.</para>

        <para>Schließlich haben wir noch den Formularabschluss.</para>

        <para>Code:</para>

        <screen> $output-&gt;FormEnd(); </screen>

        <para>wird zu</para>

        <para>Template:</para>

        <screen> &lt;/form&gt; </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e187" />1.8. Arbeite dich
        systematisch durch alle Ausgabefunktionen</title>

        <para>Ich fand es am besten, die ganze pnHTML Ausgabe einer Funktion
        zu kommentieren und dann einzeln an jedem "Stück" der Ausgabe zu
        arbeiten, bis jedes "Stück" geändert ist. Mit "Stück" meine ich ein
        Codesegment, wie:</para>

        <screen> // Name $row = array(); $output-&gt;SetOutputMode(_PNH_RETURNOUTPUT); $row[] = $output-&gt;Text(pnVarPrepForDisplay(_EXAMPLENAME)); $row[] = $output-&gt;FormText('name', '', 32, 32); $output-&gt;SetOutputMode(_PNH_KEEPOUTPUT); $output-&gt;SetInputMode(_PNH_VERBATIMINPUT); $output-&gt;TableAddrow($row, 'left'); $output-&gt;SetInputMode(_PNH_PARSEINPUT); </screen>

        <para>In der Abfolge jedes "Stück" auskommentieren. Erst reduziere das
        Segment durch entfernen der pnHTML Zustandbestimmungswörter so das es
        zu Code wird:</para>

        <screen> // Name $row[] = $output-&gt;Text(pnVarPrepForDisplay(_EXAMPLENAME)); $row[] = $output-&gt;FormText('name', '', 32, 32); </screen>

        <para>Jetzt füge die "Verpackungs-" Tabellen HTML in die Vorlage ein
        d.h.</para>

        <para>Template:</para>

        <screen> &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; </screen>

        <para>Jetzt füge die Sprachdefinition unter Verwendung des pnml plug
        in hinzu und entfernen die normale Sprachdefinition, d.h.</para>

        <para>Code:</para>

        <screen> // Name $row[] = $output-&gt;FormText('name', '', 32, 32); </screen>

        <para>Template:</para>

        <screen> &lt;tr&gt; &lt;td&gt;&lt;!--[pnml name="_EXAMPLENAME"]--&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; </screen>

        <para>Jetzt füge die Steuerung für das Formular hinzu und entferne das
        letzte Stück Code.</para>

        <para>Template:</para>

        <screen> &lt;tr&gt; &lt;td&gt;&lt;!--[pnml name="_EXAMPLENAME"]--&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="name" type="text" size="32" maxlength="32"&gt;&lt;/td&gt; &lt;/tr&gt; </screen>

        <para>Wiederhole diese Schritte für jedes pnHTML Stück in der
        gegenwärtigen Funktion.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e218" />1.9. Ändere, was von der
        Ausgabeerklärung zurück kommt</title>

        <para>Anstelle der Ausgabe eines pnHTML Objekts geben wir die Ausgabe
        eines pnRender Objekts zurück. So daß aus der Rückgabe der
        Ausgabeerklärung</para>

        <screen> // Return the output that has been generated by this function return $output-&gt;GetOutput(); </screen>

        <para>dieses wird</para>

        <screen> // Return the output that has been generated by this function return $pnRender-&gt;fetch(&lt;template_name_including_extension&gt;); </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e229" />1.10. Daten dem Template
        zuweisen</title>

        <para>Für jene Formulare, die Daten enthalten (modify, modifyconfig
        usw.) müssen wir dann der Vorlage die Daten zuweisen. Normalerweise
        hätte ein API-Anruf die Daten von der Datenbank bekommen. d.h.:</para>

        <screen> // The user API function is called. This takes the item ID which we // obtained from the input and gets us the information on the appropria\ te // item. If the item does not exist we post an appropriate message and // return $item = pnModAPIFunc('Example', 'user', 'get', array('tid' =&gt; $ti\ d)); </screen>

        <para>Jetzt haben wir die Teile um sie einfach in das Template
        einzufügen, d.h.</para>

        <screen> // Assign the item array to the template $pnRender-&gt;assign('item', $item); </screen>

        <para>Ebenso übertragen wir auf dieselbe Weise Modul vars zum Template
        d.h.</para>

        <screen> // Bold $pnRender-&gt;assign('bold', pnModGetVar('Example', 'bold')); </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e242" />1.11. Ausgabedaten ins
        Template einfügen</title>

        <para>Wir haben eine Templatestruktur und wir haben Daten die dem
        Template hinzugefügt werden wollen. Der letzte Schritt ist die Daten
        dem Template hinzuzufügen, wenn die Funktionen (modify, view,
        modifyconfig usw.) sie brauchen.</para>

        <para>Das Verwenden des Formularbeispiels von Schritt 1.8 und der
        Datenzuweisung von Schritt 1.10</para>

        <para>&lt;tr&gt;</para>

        <para>&lt;td&gt;&lt;!--[pnml
        name="_EXAMPLENAME"]--&gt;&lt;/td&gt;</para>

        <para>&lt;td&gt;&lt;input name="name" type="text" size="32"
        maxlength="32"&gt;&lt;/td&gt;</para>

        <para>&lt;/tr&gt;</para>

        <para>wird dann zu</para>

        <screen> &lt;tr&gt; &lt;td&gt;&lt;!--[pnml name="_EXAMPLENAME"]--&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="name" type="text" size="32" maxlength="32" \ value="&lt;!--[$name|pnvarprepfordisplay]--&gt;"&lt;/td&gt; &lt;/tr&gt; </screen>

        <para><emphasis>Merke:</emphasis> Wenn dein Datenwert HTML Code
        enthalten könnte, ändert den pnvarprepfordisplay Bestimmungswert in
        pnvarprephtmldisplay.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e261" />1.12. Der Rest......</title>

        <para>Schritt 1.7-1.11 muss für jede Funktion in der Administration
        wiederholt werden, die eine Ausgabe macht. Im Beispielmodul sind dies
        die Funktionen "example_admin_new, example_admin_modify,
        example_admin_view and example_admin_modifyconfig". An dieser Stelle
        solltest du alles in das Administrationsmenü übertragen haben. Und
        jetzt: Testen!, Testen!, Testen!.</para>

        <para>Die Benutzerseite eines Moduls wird wahrscheinlich weniger
        aufwendig zu testen sein aber du wirst jedes Modul prüfen müssen und
        du mußt eine ungefähre Vorstellung haben, wie die Prozesse
        funktionieren. Zusätzlich muß eine System zum Zwischenspeichern für
        den Benutzer formuliert werden. Siehe das Beispielmodul als
        funktionierendes Beispiel für Vorlagenzwischenspeicherung.</para>

        <para>Hoffentlich werden diese Notizen von wenigstens einer Person
        nützlich gefunden ;-). Wie in der Einführung schon gesagt, es sind
        Notizen eines Verfahrens nach dem ich gearbeitet habe - nicht mehr,
        nicht weniger. Jeder Entwickler wird ohne Zweifel, seinen eigenen Weg
        und seine eigene Methoden finden. Wenn ihr Kommentare, Vorschläge oder
        Zusätze habt, dann schickt mir bitte eine E-Mail an: markwest ät
        postnuke dot com. Beschwerden und Beleidigungen bitte an folgende
        Adresse schicken: B dot Gates ät Microsoft dot com ... ....</para>
      </section>
    </section>

    <section remap="h2">
      <title><anchor id="dbdoclet.id.d0e270" />2. Zusatzmerkmale vom
      Beispielmodul</title>

      <para>Dieser Abschnitt bedeckt einige der Zusatzmerkmale, die im
      Beispielmodul gefunden werden können. Einige Merkmale können nur in CVS
      je nach Freigabeplan vom Beispielmodulcode gefunden werden.</para>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e275" />2.1. Tabellen
        Anfangsblöcke</title>

        <para>Viele pnHTML Module formatieren Tabellen direkt durch aufrufen
        der Zeilen und Spalten Methode der pnHTML Klasse. Das Negative daran
        ist das die Tabellen in diesem Modul nicht den
        Tabellenanfangsblockbefehl (th) benutzen. Erzeuge irgendwelche
        Anfangsblöcke die den Tabelleanfangsblockbefehl gebrauchen. z.B. die
        Administrationsübersichtsfunktion vom Beispielmodul</para>

        <screen> &lt;table style="text-align:center;width:100%;" border="3"&gt; &lt;tr&gt; &lt;th&gt;&lt;!--[pnml name="_EXAMPLENAME"]--&gt;&lt;/th&gt; &lt;th&gt;&lt;!--[pnml name="_EXAMPLENUMBER"]--&gt;&lt;/th&gt; &lt;th&gt;&lt;!--[pnml name="_EXAMPLEOPTIONS"]--&gt;&lt;/th&gt; &lt;/tr&gt; ....... </screen>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e283" />2.2. HTML Einhaltung</title>

        <para>Berücksichtige immer die HTML Einhaltung. Der Kern von PN .726
        war ca. 95% HTML 4.01 Übergangsfähig. Es ist wichtig, deinen Code
        durch eine HTML Prüfer vor der Freigabe zu prüfen. Der W3C Prüfer kann
        bei <ulink url="http://validator.w3.org"><emphasis
        role="underline">http://validator.w3.org</emphasis></ulink> gefunden
        werden.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e291" />2.3.
        Programmeinstiegsmöglichkeiten</title>

        <para>Stelle immer sicher, daß dein Modul Transformations- und
        Anzeigemöglichkeiten unterstützt. Um Transformationsmöglichkeiten zu
        testen, verwendet den Kern vom Autolinks-Modul. Um
        Anzeigenmöglichkeiten zu testen, verwendet den Kern vom
        Ratings-Modul.</para>
      </section>

      <section remap="h3">
        <title><anchor id="dbdoclet.id.d0e296" />2.4. PN .8 Zukunft</title>

        <para>Im Bereich von templating gibt es eine Anzahl von zusätzlichen
        Schritten, die du mit deinem Modul ergreifen kannst, um jetzt
        sicherzustellen, daß dein Modul einigen den von PN .8 gesetzten
        Standards entspricht. Diese Tipps entstehen konstant weiter, also wenn
        ein Modul entwickelt wird, immer in die CVS schauen.</para>

        <section remap="h4">
          <title><anchor id="dbdoclet.id.d0e301" />2.4.1. Verwerfen von
          Befehlen und Eigenschaften</title>

          <para>Obwohl innerhalb des HTML strikt gültig, werden viele Befehle
          und Eigenschaften missbilligt oder nicht für den Gebrauch empfohlen.
          Stelle sicher, daß dein Template nicht einige dieser Befehle und
          Eigenschaften verwenden. Einige Beispiele sind</para>

          <para>Schrifttypenbefehl z.B. &lt;font class="pn-normal"&gt; -
          ersetzen diesen durch eine span oder div Befehl z.B. &lt;span
          class="pn-normal"&gt; . Schrifttypen sollten von der Stilvorlage
          kontrolliert werden.</para>

          <para>align Eigenschaft aus dem div Befehl z.B. &lt;div
          align="center"&gt; - das Thema stylesheet sollte Layout von divs
          kontrollieren. Zu überschreiben des Themenstandards sollte im
          Einzellfall div einen Inline-Stil verwenden. z.B. &lt;div
          style="text-align:center;"&gt;</para>
        </section>

        <section remap="h4">
          <title><anchor id="dbdoclet.id.d0e310" />2.4.2.
          Verfügbarkeit</title>

          <para>Sicherstellen, daß dein Template 'verfügbaren Code'
          produziert. Dies ist wichtig, um das Publikum für PN und dein Modul
          zu verbreitern. Während PN .7x keine Schritt in diese Richtung
          machte, wird PN .8 gegenwärtig durch verschiedenen
          Verfügbarkeitskontrollen geführt , und das Entwickler Team lernt die
          Richtung, verfügbaren Code zu produzieren.</para>

          <para>d.h. Alle Formelemente sollten eine Beschriftung haben und
          diese Beschriftung mit dem dazugehörigen Formelement benutzt die
          'for' Eigenschaft von der Beschriftung und die ID Eigenschaft vom
          Formelement. Wie das Formelement in Schritt 1.11</para>

          <screen> &lt;tr&gt; &lt;td&gt;&lt;!--[pnml name="_EXAMPLENAME"]--&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="name" type="text" size="32" maxlength="32" \ value="&lt;!--[$name|pnvarprepfordisplay]--&gt;"&lt;/td&gt; &lt;/tr&gt; </screen>

          <para>wird zu</para>

          <screen> &lt;tr&gt; &lt;td&gt;&lt;label for="example_name"&gt;&lt;!--[pnml name="_EXAMPLE\ NAME"]--&gt;&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input id="example_name" name="name" type="text" size="3\ 2" maxlength="32" value="&lt;!--[$name|pnvarprepfordisplay]--&gt;"&gt;&lt;/\ td&gt; &lt;/tr&gt; </screen>
        </section>

        <section remap="h4">
          <title><anchor id="dbdoclet.id.d0e325" />2.4.3. PHPDoc
          Kommentare</title>

          <para>PHPDoc Kommentarblöcke werden verwendet um automatisch aus
          einem Stück Code eine Dokumentation zu generieren. Das Beispielmodul
          wird mit Hilfe von PHPDoc Kommentaren dokumentiert. Wenn du ein
          Modul umwandelst, denke daran, PHPDoc Kommentare überall in deinem
          Code hinzu zufügen. Alle Details über PHPDoc können bei <ulink
          url="http://phpdocu.sourceforge.net">http://phpdocu.sourceforge.net</ulink>
          gefunden werden.</para>
        </section>
      </section>
    </section>
  </chapter>
</book>