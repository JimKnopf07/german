<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<chapter id="pnrender.moddev" lang="en-US"
         revision="$Revision$ $Date$"
         status="draft">
  <!-- $Id$ -->

  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Jörg</firstname>

        <surname>Napp</surname>

        <affiliation>
          <jobtitle>Developer</jobtitle>

          <orgname>PostNuke</orgname>
        </affiliation>
      </author>

      <author>
        <firstname>Mark</firstname>

        <surname>West</surname>

        <affiliation>
          <jobtitle>Developer</jobtitle>

          <orgname>PostNuke</orgname>
        </affiliation>
      </author>

      <author>
        <firstname>Steffen</firstname>

        <surname>Voss</surname>

        <affiliation>
          <jobtitle>German Translation</jobtitle>

          <orgname><ulink
          url="http://www.post-nuke.net">post-nuke.net</ulink></orgname>
        </affiliation>
      </author>
    </authorgroup>

    <releaseinfo>$Revision$</releaseinfo>

    <date>$Date$</date>

    <keywordset>
      <keyword>Smarty</keyword>

      <keyword>pnRender</keyword>

      <keyword>Xanthia Modul Entwicklung</keyword>
    </keywordset>
  </chapterinfo>

  <title>pnRender für Modulentwickler</title>

  <para>Dieses Kapitel befaßt sich mit den grundsätzlichen Konzepten, die
  Modulentwickler bei ihrer Arbeit beachten sollten.</para>

  <section id="pnrender.moddev.basic">
    <title>Wie funktioniert pnRender in Modulen?</title>

    <para>Die Idee hinter Smarty ist sehr einfach: Im Modul oder im Block
    werden Variablen befüllt, diese werden dann an das Postnuke-System
    übergeben und dann in das Layout eingefügt. So wird aus Templates und
    Variablen die Seite aufgebaut. </para>

    <tip>
      <title>Assoziative Arrays</title>

      <para>Statt einfacher Variable/Wert-Paare können auch assziative Arrays
      an das Template übergeben werden. Das kann in einigen Fällen ganz
      praktisch sein, wenn es sich dabei zum Beispiel um Arrays handelt, die
      schon von der API erzeugt werden.</para>
    </tip>

    <section id="pnrender.moddev.basic.module">
      <title>pnRender in einem einfachen Modul</title>

      <para>Hier ein kurzes Beispiel für den Einsatz von pnRender in einem
      einfachen Modul:</para>

      <programlisting>$output =&amp; new pnRender(); 
$output-&gt;assign('bspVariable', $irgendeinWert); 
return $output-&gt;fetch('index.htm');</programlisting>
    </section>

    <section id="pnrender.moddev.basic.hook">
      <title>pnRender in einem Hook Module</title>

      <para>Wenn pnRender in einem Hook-Modul benutzt wird, muß der Name des
      Moduls übergeben werden, damit das System weiß zu welchen Modul welche
      Ausgaben gehören. Das ist wichtig, da Hooks sich ja in die Ausgaben
      anderer Module einklinken.</para>

      <programlisting>$output =&amp; new pnRender('MeinHookModul'); 
$output-&gt;assign('bspVariable', $irgendeinWert);
return $output-&gt;fetch('index.htm');</programlisting>
    </section>

    <section id="pnrender.moddev.basic.blocks">
      <title>pnRender in einem Block</title>

      <para>Auch in Blöcken mit der Modulname übergeben werden:</para>

      <programlisting>$output =&amp; new pnRender('MeinModul'); 
$output-&gt;assign('bspVariable', $irgendeinWert); 
$row['content'] = $output-&gt;fetch('meinblock_template.htm'); 
return themesideblock($row);</programlisting>
    </section>
  </section>

  <section id="pnrender.moddev.files">
    <title>Lage der Dateien</title>

    <para>Modul-Templates werden im Verzeichnis jedes Moduls im
    Unterverzeichnis <filename>pntemplates</filename> gespeichert.</para>

    <para>Zusätzliche Smarty-<olink targetdoc="pnRender.Reference.xml"
    targetptr="pnrender.tempdev.plugins">Plugins</olink> müssen im
    Unterverzeichnis <filename>plugins</filename> von
    <filename>pntemplates</filename> abgelegt werden.</para>

    <para>Konfigaurationsdateien werden ebenfalls in einem Unterverzeichnis
    von <filename>pntemplates</filename> gespeichert:
    <filename>config</filename></para>

    <para>Mehr Informationen zu möglichen Konfigurationen gibt es in der
    <ulink url="http://smarty.php.net/manual/en/config.files.php">Smarty
    dokumentation</ulink>.</para>

    <screenshot>
      <mediaobject>
        <objectinfo>
          <title>Lage der Dateien</title>
        </objectinfo>

        <imageobject>
          <imagedata fileref="pnRender.ModuleDirectoryStructure.gif"
                     format="JPG" />
        </imageobject>

        <textobject>
          <phrase>Dateinstruktur im Modulverzeichnis</phrase>
        </textobject>
      </mediaobject>
    </screenshot>
  </section>

  <section id="pnrender.moddev.themetemplates">
    <title>Theme-spezifische Templates</title>

    <para>Für Theme-Disgner gibt es die Möglichkeit zusammen mit dem Theme
    Templates für verschiedene Module vorzubereiten. Wenn ein solches
    Theme-abhängiges Modul-Template existiert, wird dieses statt des Originals
    benutzt. Das bedeutet, dass Theme-Designer nicht nur das generelle Layout
    bestimmen können. Es ist auch möglich, dass sie festlegen wie in ihrem
    Theme zum Beispiel die News oder der Kalender aussehen sollen.</para>

    <para>Diese Modul-Templates liegen dann zusammen mit dem Rest des Themes
    in einem Verzeichnis. Dort muß dann nur ein Unterverzeichnis für die
    Modultemplates eingerichtet werden
    <filename>templates/<replaceable>&lt;modulename&gt;</replaceable></filename>.
    Auch hier können wiederum Unterverzeichnisse für Configs und Plugins
    erstellt werden.</para>

    <screenshot>
      <mediaobject>
        <objectinfo>
          <title>Layoutabhängige Modultemplates</title>
        </objectinfo>

        <imageobject>
          <imagedata fileref="pnRender.ThemeDirectoryStructure.gif"
                     format="JPG" />
        </imageobject>

        <textobject>
          <phrase>Verzeichnisstruktur für Modultemplates im Theme</phrase>
        </textobject>
      </mediaobject>
    </screenshot>
  </section>

  <section id="pnrender.moddev.caching">
    <title>Caching</title>

    <para>Aus der Smarty Dokumentatuion:</para>

    <blockquote>
      <attribution><ulink
      url="http://smarty.php.net/manual/en/caching.php">Smarty
      Dokumentation</ulink></attribution>

      <para>Caching wird verwendet, um <command>display()</command> oder
      <command>fetch()</command> Aufrufe durch zwischenspeichern (cachen) der
      Ausgabe in einer Datei zu beschleunigen. Falls eine gecachte Version des
      Aufrufs existiert, wird diese ausgegeben, anstatt die Ausgabe neu zu
      generieren. Caching kann die Performance vor allem dann deutlich
      verbessern, wenn Templates längere Rechenzeit beanspruchen. Weil die
      Ausgabe von <command>display()</command> und <command>fetch()</command>
      gecached wird, kann ein Cache verschiedene Templates,
      Konfigurationsdateien usw. enthalten.</para>
    </blockquote>

    <para>Zum einen kann der Site-Administrator entscheiden, ob überhaupt
    Caching auf seiner Site eingesetzt werden soll. Diese Einstellung kann
    aber vom Modulentwickler "übergangen" werden, indem er den caching-Wert im
    pnRender Objekt selbst setzt. Er kann <command>caching</command> zum
    Beispiel auf <command>false</command> setzen, wenn er die Inhalte aus
    bestimmten gründen nicht gecacht haben will. Auf <command>true</command>
    kann man den Wert auch setzen, das würde dann aber dem Administrator den
    Einfluß auf das Caching entziehen.</para>

    <section id="pnrender.moddev.caching.display">
      <title>Ausgaben mit Caching</title>

      <para>Jede anzuzeigende einzelne Seite muss eine eigene Cache-ID
      bekommen. Das wird in den meisten Fällen einfach die ID des Inhalts sein
      (News-Artikel-ID, Download-ID...) - so weiss das System, ob für diesen
      Inhalt schon eine gecachte Seite vorliegt oder nicht.</para>

      <programlisting role="example">return $pnRender-&gt;Fetch('example_user_display.htm', $tid);</programlisting>

      <important>
        <para>Wenn eine Seite verschiedene Inhalte für Benutzer mit
        verschiedenen Zugriffsrechten enthält, sollte diese Seite nicht
        gecacht werden. Es kann sonst sein, dass den Usern immer wieder die
        Seite angezeigt wird, die mit den Rechten des ersten Users erzeugt
        wurde.</para>

        <para>Die Postnuke-Entwickler arbeiten aber an einer Lösung für dieses
        Problem.</para>
      </important>
    </section>

    <section id="pnrender.moddev.caching.proctime">
      <title>Performance erhöhen</title>

      <para>Bei der Anwendung der <command>is_cached</command> Methode auf das
      pnRender Objekt, kann man herausfinden, ob die Seite schon gecacht ist.
      Dadurch kann man die Performance erheblich steigern und zum Beispiel
      Datenbankabfragen reduzieren.</para>

      <programlisting role="example">/**
 * display item
 * Dies ist die Standartfunktion mit der man detailierte Informationen zu einem bestimmten Inhalt
 * vom Modul aufrufen kann.
 */
function Example_user_display($args)
{
    $tid = pnVarCleanFromInput('tid');
[...]
//Check der Zugriffsrechte
[...]

    $pnRender = new pnRender();

    // Sind die Inhalte gecacht?
    if ($pnRender-&gt;is_cached('example_user_display.htm', $tid)) {
       return $pnRender-&gt;fetch('example_user_display.htm', $tid);
    }

[...]
// weiterer Code
[...]
// Aufruf des Templates mit Cache-ID
    return $pnRender-&gt;Fetch('example_user_display.htm', $tid);
}</programlisting>

      <para><command>is_cached</command> sollte so früh wie möglich im Code
      aufgerufen werden, um unnötige Arbeit zu ersparen.</para>
    </section>

    <section id="pnrender.moddev.caching.clearing">
      <title>Cache löschen</title>

      <para>Wenn Inhalte verändert, gelöscht oder hinzugefügt werden, müssen
      alle relevanten, gecachten Seiten gelöscht werden. Andernfalls könnten
      veraltete Daten an den Browser geschickt werden.</para>

      <programlisting role="example">function Example_admin_update($args)
{
[...]
    if(pnModAPIFunc('Example',
                    'admin',
                    'update',
                    array('tid'    =&gt; $tid,
                          'name'   =&gt; $name,
                          'number' =&gt; $number))) {
        // Update Erfolgreich? Dann:
        pnSessionSetVar('statusmsg', pnVarPrepHTMLDisplay(_EXAMPLEUPDATED));

        // Übersicht &amp; Seite im Cache löschen
        $pnRender =&amp; new pnRender();
        $pnRender-&gt;clear_cache('example_user_row.htm', $tid);
        $pnRender-&gt;clear_cache('example_user_display.htm', $tid);
    }

    // Weiterleitung zu einer anderen Funktion
    pnRedirect(pnModURL('Example', 'admin', 'view'));

    // Return
    return true;
}</programlisting>

      <para>In diesem Beispiel kann man ersehen, wie alle abhängigen Seiten
      gelöscht werden können.</para>
    </section>
  </section>
</chapter>